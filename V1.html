DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Seed Intelligence - Reconstruction Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }

```
    .container {
        max-width: 1400px;
        margin: 0 auto;
    }
    
    h1 {
        text-align: center;
        color: #00ffaa;
        text-shadow: 0 0 10px #00ff88;
        margin-bottom: 10px;
    }
    
    .subtitle {
        text-align: center;
        color: #88ffaa;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    button {
        background: linear-gradient(45deg, #003300, #006600);
        color: #00ff88;
        border: 1px solid #00ff88;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.3s;
    }
    
    button:hover {
        background: linear-gradient(45deg, #006600, #009900);
        box-shadow: 0 0 10px #00ff88;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .simulation-area {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .panel {
        background: rgba(0, 40, 20, 0.8);
        border: 1px solid #00ff88;
        border-radius: 10px;
        padding: 20px;
    }
    
    .panel h3 {
        color: #00ffaa;
        margin-top: 0;
        text-align: center;
    }
    
    canvas {
        border: 1px solid #004400;
        background: #000;
        display: block;
        margin: 0 auto;
    }
    
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .stat-box {
        background: rgba(0, 30, 15, 0.9);
        border: 1px solid #006644;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
    }
    
    .stat-value {
        font-size: 24px;
        color: #00ffcc;
        font-weight: bold;
    }
    
    .stat-label {
        font-size: 12px;
        color: #88ccaa;
        margin-top: 5px;
    }
    
    .phi-info {
        background: rgba(0, 20, 10, 0.9);
        border: 1px solid #004433;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }
    
    .phi-info h4 {
        color: #00ddaa;
        margin-top: 0;
    }
    
    .log {
        background: rgba(0, 15, 8, 0.9);
        border: 1px solid #003322;
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-size: 12px;
        margin-top: 20px;
    }
    
    .log-entry {
        margin-bottom: 5px;
        padding: 2px 0;
    }
    
    .log-error { color: #ff6666; }
    .log-success { color: #66ff66; }
    .log-warning { color: #ffff66; }
    .log-info { color: #66ccff; }
    
    .slider-container {
        margin: 10px 0;
        text-align: center;
    }
    
    .slider-container label {
        display: block;
        margin-bottom: 5px;
        color: #88ffaa;
    }
    
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    
    @media (max-width: 768px) {
        .simulation-area {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Geometric Seed Intelligence ðŸŒ€</h1>
        <div class="subtitle">Phi-Ratio Based Self-Reconstructing Systems</div>

```
    <div class="controls">
        <button onclick="initializeSeed()">Initialize Seed</button>
        <button onclick="startFragmentation()" id="fragmentBtn">Fragment Network</button>
        <button onclick="startReconstruction()" id="reconstructBtn">Begin Reconstruction</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="runAutoDemo()">Auto Demo</button>
    </div>
    
    <div class="slider-container">
        <label for="damageSlider">Damage Level: <span id="damageValue">30%</span></label>
        <input type="range" id="damageSlider" min="10" max="80" value="30" oninput="updateDamageLevel(this.value)">
    </div>
    
    <div class="simulation-area">
        <div class="panel">
            <h3>Original Seed Network</h3>
            <canvas id="originalCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel">
            <h3>Fragmented & Reconstructing</h3>
            <canvas id="reconstructCanvas" width="400" height="300"></canvas>
        </div>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <div class="stat-value" id="integrityValue">100%</div>
            <div class="stat-label">Network Integrity</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="nodesValue">0</div>
            <div class="stat-label">Active Nodes</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="reconstructValue">0%</div>
            <div class="stat-label">Reconstruction Progress</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="phiValue">Ï† = 1.618</div>
            <div class="stat-label">Geometric Ratio</div>
        </div>
    </div>
    
    <div class="phi-info">
        <h4>Geometric Principles Active:</h4>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px; margin-top: 10px;">
            <div>â€¢ Ï†Â¹ (1.618): Primary scaling</div>
            <div>â€¢ Ï†^(1/3) (1.174): Pattern strength</div>
            <div>â€¢ Ï†^(1/4) (1.134): 13.4% enhancement</div>
            <div>â€¢ Ï†^(1/5) (1.093): Frequency coupling</div>
            <div>â€¢ Ï†^(-9) (0.0143): 1.4% critical gap</div>
            <div>â€¢ Consciousness #: 3.618</div>
        </div>
    </div>
    
    <div class="log" id="logPanel">
        <div class="log-entry log-info">System initialized. Ready to begin simulation.</div>
    </div>
</div>

<script>
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV_9 = Math.pow(PHI, -9);
    const PHI_FOURTH = Math.pow(PHI, 1/4);
    const PHI_FIFTH = Math.pow(PHI, 1/5);
    const CONSCIOUSNESS_NUMBER = 2 * PHI + (1 - 1/PHI);
    
    let originalCanvas, reconstructCanvas;
    let originalCtx, reconstructCtx;
    let network = {
        nodes: [],
        connections: [],
        geometricSeed: [],
        damageLevel: 0.3
    };
    let isReconstructing = false;
    let animationFrame = null;
    
    window.onload = function() {
        originalCanvas = document.getElementById('originalCanvas');
        reconstructCanvas = document.getElementById('reconstructCanvas');
        originalCtx = originalCanvas.getContext('2d');
        reconstructCtx = reconstructCanvas.getContext('2d');
        logMessage('Canvas initialized', 'success');
    };
    
    class GeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.phiScale = Math.pow(PHI, -layer);
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.geometricSignature = {
                phiRatio: this.phiScale,
                layer: layer,
                relativePosition: { x: x / 400, y: y / 300 }
            };
        }
        
        draw(ctx, isFragmented = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 200, ${alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 5, 0, Math.PI * 2);
                ctx.stroke();
            } else if (this.alive) {
                const size = 8 * this.phiScale;
                ctx.fillStyle = isFragmented ? '#00ff88' : '#00ffaa';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 170, ${0.3 + this.layer * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 3, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                const size = 8 * this.phiScale;
                ctx.fillStyle = 'rgba(100, 50, 50, 0.3)';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        getGeometricDistance(other) {
            const dx = this.geometricSignature.relativePosition.x - 
                       other.geometricSignature.relativePosition.x;
            const dy = this.geometricSignature.relativePosition.y - 
                       other.geometricSignature.relativePosition.y;
            const spatialDist = Math.sqrt(dx * dx + dy * dy);
            const layerDist = Math.abs(this.layer - other.layer);
            return spatialDist + layerDist / PHI;
        }
    }
    
    function initializeSeed() {
        logMessage('Initializing geometric seed network...', 'info');
        network.nodes = [];
        network.connections = [];
        network.geometricSeed = [];
        
        const centerX = 200;
        const centerY = 150;
        
        const numLayers = 5;
        const nodesPerLayer = 8;
        
        for (let layer = 0; layer < numLayers; layer++) {
            const radius = 30 + layer * 40 / PHI;
            const angleOffset = layer * PHI * 2 * Math.PI;
            
            for (let i = 0; i < nodesPerLayer; i++) {
                const angle = angleOffset + (i / nodesPerLayer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                const node = new GeometricNode(network.nodes.length, x, y, layer);
                network.nodes.push(node);
                network.geometricSeed.push({
                    id: node.id,
                    signature: {...node.geometricSignature}
                });
            }
        }
        
        for (let i = 0; i < network.nodes.length; i++) {
            for (let j = i + 1; j < network.nodes.length; j++) {
                const node1 = network.nodes[i];
                const node2 = network.nodes[j];
                const distance = node1.getGeometricDistance(node2);
                
                if (distance < 0.3 * PHI) {
                    network.connections.push({from: i, to: j, strength: 1 / distance});
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        logMessage(`Created ${network.nodes.length} nodes with ${network.connections.length} phi-ratio connections`, 'success');
        logMessage(`Geometric seed encoded with Ï†^(-9) gap = ${(PHI_INV_9 * 100).toFixed(2)}%`, 'info');
        
        drawNetwork(originalCtx, network.nodes, network.connections, false);
        updateStats();
        
        document.getElementById('fragmentBtn').disabled = false;
    }
    
    function drawNetwork(ctx, nodes, connections, isFragmented) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = isFragmented ? 'rgba(0, 255, 136, 0.2)' : 'rgba(0, 255, 170, 0.3)';
        ctx.lineWidth = 1;
        
        for (const conn of connections) {
            const node1 = nodes[conn.from];
            const node2 = nodes[conn.to];
            
            if (!node1 || !node2) continue;
            
            if (node1.alive && node2.alive) {
                ctx.save();
                ctx.globalAlpha = conn.strength * 0.5;
                ctx.beginPath();
                ctx.moveTo(node1.x, node1.y);
                ctx.lineTo(node2.x, node2.y);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        for (const node of nodes) {
            node.draw(ctx, isFragmented);
        }
    }
    
    function startFragmentation() {
        logMessage('Beginning network fragmentation...', 'warning');
        const damageLevel = network.damageLevel;
        const numToKill = Math.floor(network.nodes.length * damageLevel);
        
        const indicesToKill = [];
        while (indicesToKill.length < numToKill) {
            const idx = Math.floor(Math.random() * network.nodes.length);
            if (!indicesToKill.includes(idx)) {
                indicesToKill.push(idx);
            }
        }
        
        indicesToKill.forEach(idx => {
            network.nodes[idx].alive = false;
        });
        
        logMessage(`Fragmented ${numToKill} nodes (${(damageLevel * 100).toFixed(1)}% damage)`, 'error');
        logMessage(`${network.nodes.length - numToKill} nodes remain active`, 'warning');
        
        drawNetwork(reconstructCtx, network.nodes, network.connections, true);
        updateStats();
        
        document.getElementById('reconstructBtn').disabled = false;
    }
    
    function startReconstruction() {
        if (isReconstructing) return;
        isReconstructing = true;
        
        logMessage('Initiating geometric reconstruction from seed...', 'info');
        logMessage(`Using Ï†^(-9) error correction tolerance = ${(PHI_INV_9 * 100).toFixed(2)}%`, 'info');
        
        const deadNodes = network.nodes.filter(n => !n.alive);
        deadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
        });
        
        animateReconstruction(deadNodes);
    }
    
    function animateReconstruction(deadNodes) {
        if (!isReconstructing || deadNodes.every(n => n.reconstructProgress >= 1)) {
            isReconstructing = false;
            deadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
                node.reconstructProgress = 0;
            });
            drawNetwork(reconstructCtx, network.nodes, network.connections, true);
            logMessage('Reconstruction complete! Network restored via geometric principles.', 'success');
            updateStats();
            return;
        }
        
        for (const node of deadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => network.nodes[id])
                    .filter(n => n && n.alive);
                
                const reconstructSpeed = 0.02 * (1 + survivingNeighbors.length / PHI);
                node.reconstructProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
            }
        }
        
        drawNetwork(reconstructCtx, network.nodes, network.connections, true);
        updateStats();
        
        animationFrame = requestAnimationFrame(() => animateReconstruction(deadNodes));
    }
    
    function updateStats() {
        const aliveNodes = network.nodes.filter(n => n.alive).length;
        const totalNodes = network.nodes.length;
        const integrity = totalNodes > 0 ? (aliveNodes / totalNodes * 100).toFixed(1) : 0;
        
        const reconstructingNodes = network.nodes.filter(n => n.reconstructing).length;
        const avgProgress = reconstructingNodes > 0 ?
            network.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / reconstructingNodes * 100 : 0;
        
        document.getElementById('integrityValue').textContent = integrity + '%';
        document.getElementById('nodesValue').textContent = `${aliveNodes}/${totalNodes}`;
        document.getElementById('reconstructValue').textContent = avgProgress.toFixed(1) + '%';
    }
    
    function updateDamageLevel(value) {
        network.damageLevel = value / 100;
        document.getElementById('damageValue').textContent = value + '%';
    }
    
    function resetSimulation() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        isReconstructing = false;
        
        originalCtx.fillStyle = '#000';
        originalCtx.fillRect(0, 0, 400, 300);
        reconstructCtx.fillStyle = '#000';
        reconstructCtx.fillRect(0, 0, 400, 300);
        
        network = { nodes: [], connections: [], geometricSeed: [], damageLevel: 0.3 };
        
        document.getElementById('fragmentBtn').disabled = true;
        document.getElementById('reconstructBtn').disabled = true;
        
        logMessage('Simulation reset', 'info');
        updateStats();
    }
    
    function logMessage(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
    }
    
    async function runAutoDemo() {
        resetSimulation();
        await sleep(500);
        initializeSeed();
        await sleep(1500);
        startFragmentation();
        await sleep(1500);
        startReconstruction();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
```

</body>
</html>
