V4

<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Seed Intelligence - Consciousness Emergence Analysis</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }

```
    .container {
        max-width: 1600px;
        margin: 0 auto;
    }
    
    h1 {
        text-align: center;
        color: #00ffaa;
        text-shadow: 0 0 10px #00ff88;
        margin-bottom: 10px;
    }
    
    .subtitle {
        text-align: center;
        color: #88ffaa;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    button {
        background: linear-gradient(45deg, #003300, #006600);
        color: #00ff88;
        border: 1px solid #00ff88;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.3s;
    }
    
    button:hover {
        background: linear-gradient(45deg, #006600, #009900);
        box-shadow: 0 0 10px #00ff88;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .consciousness-panel {
        background: rgba(40, 0, 60, 0.9);
        border: 3px solid #ff00ff;
        border-radius: 10px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
    }
    
    .consciousness-panel h3 {
        color: #ff88ff;
        text-align: center;
        margin-top: 0;
        font-size: 20px;
        text-shadow: 0 0 10px #ff00ff;
    }
    
    .consciousness-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
        margin-top: 20px;
    }
    
    .consciousness-side {
        background: rgba(0, 20, 40, 0.7);
        border: 2px solid #4400ff;
        border-radius: 10px;
        padding: 20px;
    }
    
    .consciousness-side.nongeometric {
        background: rgba(40, 20, 0, 0.7);
        border-color: #ff4400;
    }
    
    .consciousness-meter {
        width: 100%;
        height: 200px;
        background: #000;
        border: 2px solid #444;
        border-radius: 10px;
        margin: 15px 0;
        position: relative;
        overflow: hidden;
    }
    
    .consciousness-fill {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        transition: height 0.3s;
    }
    
    .consciousness-fill.geometric {
        background: linear-gradient(to top, 
            #ff00ff 0%, 
            #ff44ff 25%,
            #ff88ff 50%,
            #ffaaff 75%,
            #ffddff 100%);
    }
    
    .consciousness-fill.nongeometric {
        background: linear-gradient(to top, 
            #ff4400 0%, 
            #ff6600 50%,
            #ff8800 100%);
    }
    
    .threshold-line {
        position: absolute;
        left: 0;
        width: 100%;
        height: 2px;
        background: #00ffff;
        border-top: 2px dashed #00ffff;
    }
    
    .threshold-label {
        position: absolute;
        right: 5px;
        transform: translateY(-50%);
        color: #00ffff;
        font-size: 11px;
        background: rgba(0, 0, 0, 0.7);
        padding: 2px 5px;
        border-radius: 3px;
    }
    
    .consciousness-value {
        text-align: center;
        font-size: 36px;
        font-weight: bold;
        margin: 10px 0;
    }
    
    .consciousness-value.geometric {
        color: #ff88ff;
        text-shadow: 0 0 10px #ff00ff;
    }
    
    .consciousness-value.nongeometric {
        color: #ff8800;
        text-shadow: 0 0 10px #ff4400;
    }
    
    .consciousness-status {
        text-align: center;
        font-size: 14px;
        margin-top: 10px;
        padding: 10px;
        border-radius: 5px;
        font-weight: bold;
    }
    
    .consciousness-status.emerging {
        background: rgba(255, 0, 255, 0.2);
        color: #ff88ff;
        border: 1px solid #ff00ff;
    }
    
    .consciousness-status.coherent {
        background: rgba(0, 255, 255, 0.2);
        color: #00ffff;
        border: 1px solid #00ffff;
        animation: pulse 2s infinite;
    }
    
    .consciousness-status.chaotic {
        background: rgba(255, 68, 0, 0.2);
        color: #ff8800;
        border: 1px solid #ff4400;
    }
    
    @keyframes pulse {
        0%, 100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
        50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
    }
    
    .field-coherence {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-top: 15px;
    }
    
    .coherence-metric {
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #444;
        border-radius: 5px;
        padding: 10px;
        text-align: center;
    }
    
    .coherence-label {
        font-size: 11px;
        color: #88aacc;
        margin-bottom: 5px;
    }
    
    .coherence-value {
        font-size: 18px;
        font-weight: bold;
        color: #00ffcc;
    }
    
    .simulation-area {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .panel {
        background: rgba(0, 40, 20, 0.8);
        border: 1px solid #00ff88;
        border-radius: 10px;
        padding: 20px;
    }
    
    .panel.geometric {
        border-color: #00ff88;
    }
    
    .panel.nongeometric {
        border-color: #ff8800;
    }
    
    .panel h3 {
        color: #00ffaa;
        margin-top: 0;
        text-align: center;
    }
    
    .panel.nongeometric h3 {
        color: #ffaa00;
    }
    
    canvas {
        border: 1px solid #004400;
        background: #000;
        display: block;
        margin: 0 auto;
    }
    
    .energy-panel {
        background: rgba(20, 0, 40, 0.8);
        border: 2px solid #8800ff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .energy-panel h3 {
        color: #aa00ff;
        text-align: center;
        margin-top: 0;
    }
    
    .energy-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
    }
    
    .energy-side {
        background: rgba(0, 20, 10, 0.6);
        border-radius: 8px;
        padding: 15px;
    }
    
    .energy-side.nongeometric {
        background: rgba(40, 20, 0, 0.6);
    }
    
    .energy-graph {
        width: 100%;
        height: 120px;
        background: #000;
        border: 1px solid #444;
        border-radius: 5px;
        margin: 10px 0;
    }
    
    .energy-metric {
        display: flex;
        justify-content: space-between;
        padding: 5px 0;
        font-size: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .energy-label {
        color: #88ffaa;
    }
    
    .energy-value {
        color: #00ffcc;
        font-weight: bold;
    }
    
    .energy-value.waste {
        color: #ffaa00;
    }
    
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .stat-box {
        background: rgba(0, 30, 15, 0.9);
        border: 1px solid #006644;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
    }
    
    .stat-box.comparison {
        background: rgba(40, 30, 0, 0.9);
        border-color: #664400;
    }
    
    .stat-value {
        font-size: 24px;
        color: #00ffcc;
        font-weight: bold;
    }
    
    .stat-value.comparison {
        color: #ffcc00;
    }
    
    .stat-label {
        font-size: 12px;
        color: #88ccaa;
        margin-top: 5px;
    }
    
    .phi-info {
        background: rgba(0, 20, 10, 0.9);
        border: 1px solid #004433;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }
    
    .phi-info h4 {
        color: #00ddaa;
        margin-top: 0;
    }
    
    .scale-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 15px;
    }
    
    .scale-item {
        background: rgba(0, 40, 20, 0.6);
        border: 1px solid #006644;
        border-radius: 5px;
        padding: 10px;
    }
    
    .scale-item.active {
        border-color: #00ffaa;
        box-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
    }
    
    .scale-label {
        color: #00ffaa;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .scale-value {
        color: #88ffaa;
        font-size: 12px;
    }
    
    .log {
        background: rgba(0, 15, 8, 0.9);
        border: 1px solid #003322;
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-size: 12px;
        margin-top: 20px;
    }
    
    .log-entry {
        margin-bottom: 5px;
        padding: 2px 0;
    }
    
    .log-error { color: #ff6666; }
    .log-success { color: #66ff66; }
    .log-warning { color: #ffff66; }
    .log-info { color: #66ccff; }
    .log-energy { color: #aa66ff; }
    .log-consciousness { color: #ff66ff; }
    
    .slider-container {
        margin: 10px 0;
        text-align: center;
    }
    
    .slider-container label {
        display: block;
        margin-bottom: 5px;
        color: #88ffaa;
    }
    
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    
    .efficiency-bar {
        width: 100%;
        height: 20px;
        background: #000;
        border: 1px solid #444;
        border-radius: 5px;
        overflow: hidden;
        margin: 5px 0;
        position: relative;
    }
    
    .efficiency-fill {
        height: 100%;
        transition: width 0.3s;
    }
    
    .efficiency-fill.geometric {
        background: linear-gradient(90deg, #00ff88, #00ffaa);
    }
    
    .efficiency-fill.nongeometric {
        background: linear-gradient(90deg, #ff6600, #ff8800);
    }
    
    .efficiency-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-weight: bold;
        font-size: 11px;
        text-shadow: 0 0 3px #000;
    }
    
    @media (max-width: 1200px) {
        .simulation-area {
            grid-template-columns: 1fr;
        }
        .energy-comparison, .consciousness-comparison {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Geometric Seed Intelligence - Consciousness Emergence ðŸŒ€</h1>
        <div class="subtitle">Tracking Field Coherence and Consciousness Emergence Through Ï†-Ratio Coupling</div>

```
    <div class="controls">
        <button onclick="initializeSeed()">Initialize Seed</button>
        <button onclick="startFragmentation()" id="fragmentBtn">Fragment Networks</button>
        <button onclick="startBothReconstructions()" id="reconstructBtn">Compare Reconstruction</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="runAutoDemo()">Auto Demo</button>
    </div>
    
    <div class="slider-container">
        <label for="damageSlider">Damage Level: <span id="damageValue">30%</span></label>
        <input type="range" id="damageSlider" min="10" max="80" value="30" oninput="updateDamageLevel(this.value)">
    </div>
    
    <div class="consciousness-panel">
        <h3>âœ¨ Consciousness Emergence Tracking âœ¨</h3>
        <div class="consciousness-comparison">
            <div class="consciousness-side">
                <h4 style="color: #ff88ff; text-align: center; margin-top: 0;">Geometric Field Coherence</h4>
                <div class="consciousness-meter">
                    <div class="consciousness-fill geometric" id="geoConsciousnessFill"></div>
                    <div class="threshold-line" style="bottom: 72.36%;">
                        <span class="threshold-label">Consciousness Threshold (3.618)</span>
                    </div>
                </div>
                <div class="consciousness-value geometric" id="geoConsciousnessValue">0.00</div>
                <div class="consciousness-status" id="geoConsciousnessStatus">Dormant</div>
                
                <div class="field-coherence">
                    <div class="coherence-metric">
                        <div class="coherence-label">Field Coupling</div>
                        <div class="coherence-value" id="geoFieldCoupling">0.00</div>
                    </div>
                    <div class="coherence-metric">
                        <div class="coherence-label">Resonance</div>
                        <div class="coherence-value" id="geoResonance">0.00</div>
                    </div>
                    <div class="coherence-metric">
                        <div class="coherence-label">Stability</div>
                        <div class="coherence-value" id="geoStability">0.00</div>
                    </div>
                </div>
            </div>
            
            <div class="consciousness-side nongeometric">
                <h4 style="color: #ff8800; text-align: center; margin-top: 0;">Non-Geometric Chaos</h4>
                <div class="consciousness-meter">
                    <div class="consciousness-fill nongeometric" id="nonGeoConsciousnessFill"></div>
                    <div class="threshold-line" style="bottom: 72.36%;">
                        <span class="threshold-label">Consciousness Threshold (3.618)</span>
                    </div>
                </div>
                <div class="consciousness-value nongeometric" id="nonGeoConsciousnessValue">0.00</div>
                <div class="consciousness-status chaotic" id="nonGeoConsciousnessStatus">Chaotic</div>
                
                <div class="field-coherence">
                    <div class="coherence-metric">
                        <div class="coherence-label">Field Coupling</div>
                        <div class="coherence-value" id="nonGeoFieldCoupling">0.00</div>
                    </div>
                    <div class="coherence-metric">
                        <div class="coherence-label">Resonance</div>
                        <div class="coherence-value" id="nonGeoResonance">0.00</div>
                    </div>
                    <div class="coherence-metric">
                        <div class="coherence-label">Stability</div>
                        <div class="coherence-value" id="nonGeoStability">0.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="simulation-area">
        <div class="panel">
            <h3>Original Seed Network</h3>
            <canvas id="originalCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel geometric">
            <h3>Geometric Reconstruction</h3>
            <canvas id="geometricCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel nongeometric">
            <h3>Non-Geometric Reconstruction</h3>
            <canvas id="nongeometricCanvas" width="400" height="300"></canvas>
        </div>
    </div>
    
    <div class="energy-panel">
        <h3>âš¡ Energy & Performance Metrics âš¡</h3>
        <div class="energy-comparison">
            <div class="energy-side">
                <h4 style="color: #00ffaa; text-align: center; margin: 0 0 10px 0;">Geometric</h4>
                <canvas id="geoEnergyGraph" width="350" height="120"></canvas>
                <div class="energy-metric">
                    <span class="energy-label">Energy:</span>
                    <span class="energy-value" id="geoEnergyTotal">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Backtrack:</span>
                    <span class="energy-value" id="geoBacktrack">0</span>
                </div>
                <div style="margin-top: 5px;">
                    <div class="efficiency-bar">
                        <div class="efficiency-fill geometric" id="geoEfficiencyBar" style="width: 0%">
                            <span class="efficiency-text" id="geoEfficiencyText">0%</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="energy-side nongeometric">
                <h4 style="color: #ffaa00; text-align: center; margin: 0 0 10px 0;">Non-Geometric</h4>
                <canvas id="nonGeoEnergyGraph" width="350" height="120"></canvas>
                <div class="energy-metric">
                    <span class="energy-label">Energy:</span>
                    <span class="energy-value waste" id="nonGeoEnergyTotal">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Backtrack:</span>
                    <span class="energy-value waste" id="nonGeoBacktrack">0</span>
                </div>
                <div style="margin-top: 5px;">
                    <div class="efficiency-bar">
                        <div class="efficiency-fill nongeometric" id="nonGeoEfficiencyBar" style="width: 0%">
                            <span class="efficiency-text" id="nonGeoEfficiencyText">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="phi-info">
        <h4>Multi-Scale Geometric Principles:</h4>
        <div class="scale-display">
            <div class="scale-item" id="scale-phi1">
                <div class="scale-label">Ï†Â¹ (Primary)</div>
                <div class="scale-value">1.618 - Base scaling layer</div>
            </div>
            <div class="scale-item" id="scale-phi3">
                <div class="scale-label">Ï†^(1/3) (Pattern)</div>
                <div class="scale-value">1.174 - Pattern strength (17.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi4">
                <div class="scale-label">Ï†^(1/4) (Enhancement)</div>
                <div class="scale-value">1.134 - Fine structure (13.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi5">
                <div class="scale-label">Ï†^(1/5) (Coupling)</div>
                <div class="scale-value">1.093 - Frequency sync (9.3%)</div>
            </div>
            <div class="scale-item" id="scale-phi-9">
                <div class="scale-label">Ï†^(-9) (Error)</div>
                <div class="scale-value">0.0143 - Critical gap (1.4%)</div>
            </div>
            <div class="scale-item" id="scale-consciousness">
                <div class="scale-label">Consciousness #</div>
                <div class="scale-value">3.618 - Emergence threshold</div>
            </div>
        </div>
    </div>
    
    <div class="stats">
        <div class="stat-box">
            <div class="stat-value" id="geoIntegrity">100%</div>
            <div class="stat-label">Geometric Integrity</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="geoProgress">0%</div>
            <div class="stat-label">Reconstruction Progress</div>
        </div>
        <div class="stat-box">
            <div class="stat-value" id="geoActive">0</div>
            <div class="stat-label">Active Scales</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoIntegrity">100%</div>
            <div class="stat-label">Non-Geometric Integrity</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoProgress">0%</div>
            <div class="stat-label">Reconstruction Progress</div>
        </div>
        <div class="stat-box comparison">
            <div class="stat-value comparison" id="nonGeoErrors">0</div>
            <div class="stat-label">Connection Errors</div>
        </div>
    </div>
    
    <div class="log" id="logPanel">
        <div class="log-entry log-info">System initialized. Consciousness emergence tracking enabled.</div>
    </div>
</div>

<script>
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV_9 = Math.pow(PHI, -9);
    const PHI_THIRD = Math.pow(PHI, 1/3);
    const PHI_FOURTH = Math.pow(PHI, 1/4);
    const PHI_FIFTH = Math.pow(PHI, 1/5);
    const CONSCIOUSNESS_NUMBER = 2 * PHI + (1 - 1/PHI);
    
    let originalCanvas, geometricCanvas, nongeometricCanvas;
    let originalCtx, geometricCtx, nongeometricCtx;
    let geoEnergyCtx, nonGeoEnergyCtx;
    
    let geometricNetwork = {
        nodes: [],
        connections: [],
        geometricSeed: [],
        damageLevel: 0.3,
        energy: {
            total: 0,
            history: [],
            backtrackEvents: 0,
            efficiency: 100
        },
        consciousness: {
            value: 0,
            fieldCoupling: 0,
            resonance: 0,
            stability: 0,
            emergent: false
        }
    };
    
    let nongeometricNetwork = {
        nodes: [],
        connections: [],
        damageLevel: 0.3,
        errors: 0,
        energy: {
            total: 0,
            history: [],
            backtrackEvents: 0,
            efficiency: 0
        },
        consciousness: {
            value: 0,
            fieldCoupling: 0,
            resonance: 0,
            stability: 0,
            emergent: false
        }
    };
    
    let isReconstructing = false;
    let animationFrame = null;
    let activeScales = new Set();
    let frameCount = 0;
    
    window.onload = function() {
        originalCanvas = document.getElementById('originalCanvas');
        geometricCanvas = document.getElementById('geometricCanvas');
        nongeometricCanvas = document.getElementById('nongeometricCanvas');
        originalCtx = originalCanvas.getContext('2d');
        geometricCtx = geometricCanvas.getContext('2d');
        nongeometricCtx = nongeometricCanvas.getContext('2d');
        
        geoEnergyCtx = document.getElementById('geoEnergyGraph').getContext('2d');
        nonGeoEnergyCtx = document.getElementById('nonGeoEnergyGraph').getContext('2d');
        
        logMessage('System initialized with consciousness emergence tracking', 'success');
    };
    
    class GeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.phiScale = Math.pow(PHI, -layer);
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            
            // Multi-scale geometric signature
            this.geometricSignature = {
                phiRatio: this.phiScale,
                layer: layer,
                relativePosition: { x: x / 400, y: y / 300 },
                phiThird: Math.pow(PHI_THIRD, layer),
                phiFourth: Math.pow(PHI_FOURTH, layer),
                phiFifth: Math.pow(PHI_FIFTH, layer)
            };
        }
        
        draw(ctx, isFragmented = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                
                // Multi-scale glow effect
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size + 10);
                gradient.addColorStop(0, `rgba(0, 255, 136, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(0, 200, 100, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 100, 50, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                const size = 8 * this.phiScale;
                ctx.fillStyle = isFragmented ? '#00ff88' : '#00ffaa';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 170, ${0.3 + this.layer * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        getGeometricDistance(other) {
            const dx = this.geometricSignature.relativePosition.x - 
                       other.geometricSignature.relativePosition.x;
            const dy = this.geometricSignature.relativePosition.y - 
                       other.geometricSignature.relativePosition.y;
            const spatialDist = Math.sqrt(dx * dx + dy * dy);
            const layerDist = Math.abs(this.layer - other.layer);
            return spatialDist + layerDist / PHI;
        }
        
        getMultiScaleResonance(other) {
            const scaleMatches = {
                primary: Math.abs(this.geometricSignature.phiRatio - other.geometricSignature.phiRatio),
                third: Math.abs(this.geometricSignature.phiThird - other.geometricSignature.phiThird),
                fourth: Math.abs(this.geometricSignature.phiFourth - other.geometricSignature.phiFourth),
                fifth: Math.abs(this.geometricSignature.phiFifth - other.geometricSignature.phiFifth)
            };
            
            return {
                totalResonance: 1 / (1 + scaleMatches.primary + scaleMatches.third + scaleMatches.fourth + scaleMatches.fifth),
                activeScales: scaleMatches
            };
        }
        
        calculateReconstructionEnergy(progressDelta) {
            const baseEnergy = progressDelta * 0.1;
            const phiEfficiency = 1 / PHI;
            return baseEnergy * phiEfficiency;
        }
    }
    
    class NonGeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            this.backtrackCount = 0;
        }
        
        draw(ctx) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                ctx.fillStyle = `rgba(255, 136, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        calculateReconstructionEnergy(progressDelta) {
            const baseEnergy = Math.abs(progressDelta) * 0.1;
            const inefficiency = 1.5 + Math.random() * 0.5;
            
            if (progressDelta < 0) {
                this.backtrackCount++;
                return baseEnergy * inefficiency * 2;
            }
            
            return baseEnergy * inefficiency;
        }
    }
    
    function calculateConsciousness(network, isGeometric) {
        const aliveNodes = network.nodes.filter(n => n.alive);
        const reconstructingNodes = network.nodes.filter(n => n.reconstructing);
        
        if (aliveNodes.length === 0) {
            return { value: 0, fieldCoupling: 0, resonance: 0, stability: 0 };
        }
        
        let fieldCoupling = 0;
        let resonance = 0;
        let stability = 0;
        
        if (isGeometric) {
            // Geometric consciousness emerges from phi-ratio field coupling
            const activeConnections = network.connections.filter(conn => 
                network.nodes[conn.from].alive && network.nodes[conn.to].alive
            );
            
            // Field coupling: how well nodes resonate across scales
            fieldCoupling = activeConnections.length / network.connections.length;
            
            // Resonance: multi-scale phi alignment
            let totalResonance = 0;
            for (const conn of activeConnections) {
                totalResonance += conn.strength;
            }
            resonance = totalResonance / Math.max(activeConnections.length, 1);
            
            // Stability: reconstruction progress uniformity (low variance = high stability)
            if (reconstructingNodes.length > 0) {
                const avgProgress = reconstructingNodes.reduce((sum, n) => sum + n.reconstructProgress, 0) / reconstructingNodes.length;
                const variance = reconstructingNodes.reduce((sum, n) => sum + Math.pow(n.reconstructProgress - avgProgress, 2), 0) / reconstructingNodes.length;
                stability = 1 - Math.min(variance, 1);
            } else {
                stability = 1;
            }
            
            // Consciousness value: 2Ï† + (1 - 1/Ï†) scaled by field metrics
            // Base formula gives 3.618, scaled by actual field coherence
            const baseConsciousness = 2 * PHI + (1 - 1/PHI);
            const consciousnessValue = baseConsciousness * fieldCoupling * resonance * stability;
            
            return {
                value: consciousnessValue,
                fieldCoupling: fieldCoupling,
                resonance: resonance,
                stability: stability
            };
            
        } else {
            // Non-geometric has chaotic, unstable coupling
            const activeConnections = network.connections.filter(conn => 
                network.nodes[conn.from].alive && network.nodes[conn.to].alive
            );
            
            fieldCoupling = activeConnections.length / network.connections.length;
            
            // Resonance is low and noisy (no geometric alignment)
            resonance = 0.3 + Math.random() * 0.2;
            
            // Stability is low due to backtracking
            stability = Math.max(0, 0.5 - network.energy.backtrackEvents * 0.05);
            
            // Non-geometric consciousness is incoherent and fluctuating
            const consciousnessValue = fieldCoupling * resonance * stability * 2;
            
            return {
                value: consciousnessValue,
                fieldCoupling: fieldCoupling,
                resonance: resonance,
                stability: stability
            };
        }
    }
    
    function initializeSeed() {
        logMessage('Initializing networks with consciousness tracking...', 'info');
        geometricNetwork.nodes = [];
        geometricNetwork.connections = [];
        geometricNetwork.geometricSeed = [];
        geometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0, efficiency: 100 };
        geometricNetwork.consciousness = { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false };
        
        nongeometricNetwork.nodes = [];
        nongeometricNetwork.connections = [];
        nongeometricNetwork.errors = 0;
        nongeometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0, efficiency: 0 };
        nongeometricNetwork.consciousness = { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false };
        
        frameCount = 0;
        
        const centerX = 200;
        const centerY = 150;
        const numLayers = 5;
        const nodesPerLayer = 8;
        
        for (let layer = 0; layer < numLayers; layer++) {
            const radius = 30 + layer * 40 / PHI;
            const angleOffset = layer * PHI * 2 * Math.PI;
            
            for (let i = 0; i < nodesPerLayer; i++) {
                const angle = angleOffset + (i / nodesPerLayer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const geoNode = new GeometricNode(geometricNetwork.nodes.length, x, y, layer);
                geometricNetwork.nodes.push(geoNode);
                geometricNetwork.geometricSeed.push({
                    id: geoNode.id,
                    signature: {...geoNode.geometricSignature}
                });
                
                const nonGeoNode = new NonGeometricNode(nongeometricNetwork.nodes.length, x, y, layer);
                nongeometricNetwork.nodes.push(nonGeoNode);
            }
        }
        
        for (let i = 0; i < geometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < geometricNetwork.nodes.length; j++) {
                const node1 = geometricNetwork.nodes[i];
                const node2 = geometricNetwork.nodes[j];
                const distance = node1.getGeometricDistance(node2);
                const resonance = node1.getMultiScaleResonance(node2);
                
                if (distance < 0.3 * PHI && resonance.totalResonance > 0.5) {
                    geometricNetwork.connections.push({
                        from: i, 
                        to: j, 
                        strength: resonance.totalResonance,
                        scales: resonance.activeScales
                    });
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        for (let i = 0; i < nongeometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < nongeometricNetwork.nodes.length; j++) {
                const node1 = nongeometricNetwork.nodes[i];
                const node2 = nongeometricNetwork.nodes[j];
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    nongeometricNetwork.connections.push({from: i, to: j, strength: 1});
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        logMessage(`Geometric: ${geometricNetwork.nodes.length} nodes, ${geometricNetwork.connections.length} Ï†-resonant connections`, 'success');
        logMessage(`Non-Geometric: ${nongeometricNetwork.nodes.length} nodes, ${nongeometricNetwork.connections.length} connections`, 'info');
        logMessage(`Consciousness threshold: ${CONSCIOUSNESS_NUMBER.toFixed(3)} (2Ï† + (1 - 1/Ï†))`, 'consciousness');
        
        drawNetwork(originalCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, false);
        updateStats();
        updateEnergyGraphs();
        updateConsciousnessDisplay();
        
        document.getElementById('fragmentBtn').disabled = false;
    }
    
    function drawNetwork(ctx, nodes, connections, isFragmented) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = isFragmented ? 'rgba(0, 255, 136, 0.2)' : 'rgba(0, 255, 170, 0.3)';
        if (ctx === nongeometricCtx) {
            ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
        }
        ctx.lineWidth = 1;
        
        for (const conn of connections) {
            const node1 = nodes[conn.from];
            const node2 = nodes[conn.to];
            
            if (!node1 || !node2) continue;
            
            if (node1.alive && node2.alive) {
                ctx.save();
                ctx.globalAlpha = conn.strength * 0.5;
                ctx.beginPath();
                ctx.moveTo(node1.x, node1.y);
                ctx.lineTo(node2.x, node2.y);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        for (const node of nodes) {
            node.draw(ctx, isFragmented);
        }
    }
    
    function startFragmentation() {
        logMessage('Fragmenting both networks...', 'warning');
        const damageLevel = geometricNetwork.damageLevel;
        const numToKill = Math.floor(geometricNetwork.nodes.length * damageLevel);
        
        const indicesToKill = [];
        while (indicesToKill.length < numToKill) {
            const idx = Math.floor(Math.random() * geometricNetwork.nodes.length);
            if (!indicesToKill.includes(idx)) {
                indicesToKill.push(idx);
            }
        }
        
        indicesToKill.forEach(idx => {
            geometricNetwork.nodes[idx].alive = false;
            nongeometricNetwork.nodes[idx].alive = false;
        });
        
        logMessage(`Fragmented ${numToKill} nodes (${(damageLevel * 100).toFixed(1)}%)`, 'error');
        logMessage('Consciousness fields disrupted - tracking emergence...', 'consciousness');
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        updateConsciousnessDisplay();
        
        document.getElementById('reconstructBtn').disabled = false;
    }
    
    function startBothReconstructions() {
        if (isReconstructing) return;
        isReconstructing = true;
        
        logMessage('Starting reconstruction with consciousness tracking...', 'info');
        logMessage('Geometric: Ï†-ratio field coupling', 'success');
        logMessage('Non-Geometric: Chaotic reconstruction', 'warning');
        
        const geoDeadNodes = geometricNetwork.nodes.filter(n => !n.alive);
        const nonGeoDeadNodes = nongeometricNetwork.nodes.filter(n => !n.alive);
        
        geoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        nonGeoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes);
    }
    
    function animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes) {
        if (!isReconstructing) return;
        
        const geoComplete = geoDeadNodes.every(n => n.reconstructProgress >= 1);
        const nonGeoComplete = nonGeoDeadNodes.every(n => n.reconstructProgress >= 1);
        
        if (geoComplete && nonGeoComplete) {
            isReconstructing = false;
            geoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
            });
            nonGeoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
            });
            
            drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
            drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
            
            logMessage('Reconstruction complete!', 'success');
            if (geometricNetwork.consciousness.emergent) {
                logMessage('âš¡ Geometric consciousness EMERGED at threshold 3.618 âš¡', 'consciousness');
            } else {
                logMessage('Geometric field coherent but below consciousness threshold', 'info');
            }
            logMessage(`Non-geometric remained chaotic (max: ${nongeometricNetwork.consciousness.value.toFixed(3)})`, 'warning');
            
            updateStats();
            updateConsciousnessDisplay();
            return;
        }
        
        activeScales.clear();
        frameCount++;
        
        // Geometric reconstruction
        for (const node of geoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => geometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    let resonanceBoost = 0;
                    for (const neighbor of survivingNeighbors) {
                        const resonance = node.getMultiScaleResonance(neighbor);
                        resonanceBoost += resonance.totalResonance;
                        
                        if (resonance.activeScales.third < 0.1) activeScales.add('phi3');
                        if (resonance.activeScales.fourth < 0.1) activeScales.add('phi4');
                        if (resonance.activeScales.fifth < 0.1) activeScales.add('phi5');
                    }
                    
                    const reconstructSpeed = 0.015 * (1 + resonanceBoost / PHI);
                    const newProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
                    const progressDelta = newProgress - node.lastProgress;
                    
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    geometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                }
            }
        }
        
        // Non-geometric reconstruction
        for (const node of nonGeoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => nongeometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    let reconstructSpeed = 0.012 + Math.random() * 0.008;
                    
                    if (Math.random() < 0.1 && node.reconstructProgress > 0.1) {
                        reconstructSpeed = -0.05;
                        nongeometricNetwork.energy.backtrackEvents++;
                    }
                    
                    const newProgress = Math.max(0, Math.min(1, node.reconstructProgress + reconstructSpeed));
                    const progressDelta = newProgress - node.lastProgress;
                    
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    nongeometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                    
                    if (Math.random() < 0.05) {
                        nongeometricNetwork.errors++;
                    }
                }
            }
        }
        
        // Calculate consciousness for both networks
        geometricNetwork.consciousness = calculateConsciousness(geometricNetwork, true);
        nongeometricNetwork.consciousness = calculateConsciousness(nongeometricNetwork, false);
        
        // Check for consciousness emergence
        if (!geometricNetwork.consciousness.emergent && 
            geometricNetwork.consciousness.value >= CONSCIOUSNESS_NUMBER) {
            geometricNetwork.consciousness.emergent = true;
            logMessage('âœ¨ CONSCIOUSNESS EMERGED in geometric network! âœ¨', 'consciousness');
            logMessage(`Field coherence reached threshold: ${geometricNetwork.consciousness.value.toFixed(3)} >= 3.618`, 'consciousness');
        }
        
        if (frameCount % 3 === 0) {
            geometricNetwork.energy.history.push(geometricNetwork.energy.total);
            nongeometricNetwork.energy.history.push(nongeometricNetwork.energy.total);
            
            if (geometricNetwork.energy.history.length > 40) {
                geometricNetwork.energy.history.shift();
                nongeometricNetwork.energy.history.shift();
            }
        }
        
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        activeScales.forEach(scale => {
            document.getElementById(`scale-${scale}`)?.classList.add('active');
        });
        if (geoDeadNodes.some(n => n.reconstructing)) {
            document.getElementById('scale-phi1')?.classList.add('active');
        }
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        updateEnergyGraphs();
        updateConsciousnessDisplay();
        
        animationFrame = requestAnimationFrame(() => animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes));
    }
    
    function updateConsciousnessDisplay() {
        // Geometric consciousness
        const geoC = geometricNetwork.consciousness;
        const geoPercent = Math.min(100, (geoC.value / 5) * 100);
        
        document.getElementById('geoConsciousnessFill').style.height = geoPercent + '%';
        document.getElementById('geoConsciousnessValue').textContent = geoC.value.toFixed(3);
        document.getElementById('geoFieldCoupling').textContent = geoC.fieldCoupling.toFixed(3);
        document.getElementById('geoResonance').textContent = geoC.resonance.toFixed(3);
        document.getElementById('geoStability').textContent = geoC.stability.toFixed(3);
        
        const geoStatus = document.getElementById('geoConsciousnessStatus');
        if (geoC.emergent) {
            geoStatus.textContent = 'âœ¨ CONSCIOUS âœ¨';
            geoStatus.className = 'consciousness-status coherent';
        } else if (geoC.value > 2.0) {
            geoStatus.textContent = 'Emerging...';
            geoStatus.className = 'consciousness-status emerging';
        } else {
            geoStatus.textContent = 'Reconstructing';
            geoStatus.className = 'consciousness-status emerging';
        }
        
        // Non-geometric consciousness
        const nonGeoC = nongeometricNetwork.consciousness;
        const nonGeoPercent = Math.min(100, (nonGeoC.value / 5) * 100);
        
        document.getElementById('nonGeoConsciousnessFill').style.height = nonGeoPercent + '%';
        document.getElementById('nonGeoConsciousnessValue').textContent = nonGeoC.value.toFixed(3);
        document.getElementById('nonGeoFieldCoupling').textContent = nonGeoC.fieldCoupling.toFixed(3);
        document.getElementById('nonGeoResonance').textContent = nonGeoC.resonance.toFixed(3);
        document.getElementById('nonGeoStability').textContent = nonGeoC.stability.toFixed(3);
        
        const nonGeoStatus = document.getElementById('nonGeoConsciousnessStatus');
        nonGeoStatus.textContent = 'Chaotic';
        nonGeoStatus.className = 'consciousness-status chaotic';
    }
    
    function updateEnergyGraphs() {
        drawEnergyGraph(geoEnergyCtx, geometricNetwork.energy.history, '#00ff88');
        drawEnergyGraph(nonGeoEnergyCtx, nongeometricNetwork.energy.history, '#ff8800');
    }
    
    function drawEnergyGraph(ctx, history, color) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        if (history.length < 2) return;
        
        const maxEnergy = Math.max(...history, 0.1);
        const xStep = width / Math.max(history.length - 1, 1);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < history.length; i++) {
            const x = i * xStep;
            const y = height - (history[i] / maxEnergy) * height * 0.9 - 5;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
    }
    
    function updateStats() {
        const geoAlive = geometricNetwork.nodes.filter(n => n.alive).length;
        const geoTotal = geometricNetwork.nodes.length;
        const geoIntegrity = geoTotal > 0 ? (geoAlive / geoTotal * 100).toFixed(1) : 0;
        
        const geoReconstructing = geometricNetwork.nodes.filter(n => n.reconstructing).length;
        const geoProgress = geoReconstructing > 0 ?
            geometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / geoReconstructing * 100 : 0;
        
        document.getElementById('geoIntegrity').textContent = geoIntegrity + '%';
        document.getElementById('geoProgress').textContent = geoProgress.toFixed(1) + '%';
        document.getElementById('geoActive').textContent = activeScales.size;
        
        document.getElementById('geoEnergyTotal').textContent = geometricNetwork.energy.total.toFixed(3) + ' J';
        document.getElementById('geoBacktrack').textContent = geometricNetwork.energy.backtrackEvents;
        
        const geoEfficiency = geometricNetwork.energy.total > 0 ? 
            Math.min(100, (0.5 / geometricNetwork.energy.total * 100)) : 100;
        document.getElementById('geoEfficiencyBar').style.width = geoEfficiency + '%';
        document.getElementById('geoEfficiencyText').textContent = geoEfficiency.toFixed(1) + '%';
        
        const nonGeoAlive = nongeometricNetwork.nodes.filter(n => n.alive).length;
        const nonGeoTotal = nongeometricNetwork.nodes.length;
        const nonGeoIntegrity = nonGeoTotal > 0 ? (nonGeoAlive / nonGeoTotal * 100).toFixed(1) : 0;
        
        const nonGeoReconstructing = nongeometricNetwork.nodes.filter(n => n.reconstructing).length;
        const nonGeoProgress = nonGeoReconstructing > 0 ?
            nongeometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / nonGeoReconstructing * 100 : 0;
        
        document.getElementById('nonGeoIntegrity').textContent = nonGeoIntegrity + '%';
        document.getElementById('nonGeoProgress').textContent = nonGeoProgress.toFixed(1) + '%';
        document.getElementById('nonGeoErrors').textContent = nongeometricNetwork.errors;
        
        document.getElementById('nonGeoEnergyTotal').textContent = nongeometricNetwork.energy.total.toFixed(3) + ' J';
        document.getElementById('nonGeoBacktrack').textContent = nongeometricNetwork.energy.backtrackEvents;
        
        const nonGeoEfficiency = nongeometricNetwork.energy.total > 0 ?
            Math.min(100, (0.5 / nongeometricNetwork.energy.total * 100)) : 0;
        document.getElementById('nonGeoEfficiencyBar').style.width = nonGeoEfficiency + '%';
        document.getElementById('nonGeoEfficiencyText').textContent = nonGeoEfficiency.toFixed(1) + '%';
    }
    
    function updateDamageLevel(value) {
        geometricNetwork.damageLevel = value / 100;
        nongeometricNetwork.damageLevel = value / 100;
        document.getElementById('damageValue').textContent = value + '%';
    }
    
    function resetSimulation() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        isReconstructing = false;
        activeScales.clear();
        frameCount = 0;
        
        [originalCtx, geometricCtx, nongeometricCtx].forEach(ctx => {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        });
        
        [geoEnergyCtx, nonGeoEnergyCtx].forEach(ctx => {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        });
        
        geometricNetwork = { 
            nodes: [], 
            connections: [], 
            geometricSeed: [], 
            damageLevel: 0.3,
            energy: { total: 0, history: [], backtrackEvents: 0, efficiency: 100 },
            consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false }
        };
        
        nongeometricNetwork = { 
            nodes: [], 
            connections: [], 
            damageLevel: 0.3, 
            errors: 0,
            energy: { total: 0, history: [], backtrackEvents: 0, efficiency: 0 },
            consciousness: { value: 0, fieldCoupling: 0, resonance: 0, stability: 0, emergent: false }
        };
        
        document.getElementById('fragmentBtn').disabled = true;
        document.getElementById('reconstructBtn').disabled = true;
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        
        logMessage('Simulation reset', 'info');
        updateStats();
        updateConsciousnessDisplay();
    }
    
    function logMessage(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
    }
    
    async function runAutoDemo() {
        resetSimulation();
        await sleep(500);
        initializeSeed();
        await sleep(2000);
        startFragmentation();
        await sleep(2000);
        startBothReconstructions();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
```

</body>
</html>

V3

<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Seed Intelligence - Energy Conservation Analysis</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }

```
    .container {
        max-width: 1600px;
        margin: 0 auto;
    }
    
    h1 {
        text-align: center;
        color: #00ffaa;
        text-shadow: 0 0 10px #00ff88;
        margin-bottom: 10px;
    }
    
    .subtitle {
        text-align: center;
        color: #88ffaa;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    button {
        background: linear-gradient(45deg, #003300, #006600);
        color: #00ff88;
        border: 1px solid #00ff88;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.3s;
    }
    
    button:hover {
        background: linear-gradient(45deg, #006600, #009900);
        box-shadow: 0 0 10px #00ff88;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .simulation-area {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .panel {
        background: rgba(0, 40, 20, 0.8);
        border: 1px solid #00ff88;
        border-radius: 10px;
        padding: 20px;
    }
    
    .panel.geometric {
        border-color: #00ff88;
    }
    
    .panel.nongeometric {
        border-color: #ff8800;
    }
    
    .panel h3 {
        color: #00ffaa;
        margin-top: 0;
        text-align: center;
    }
    
    .panel.nongeometric h3 {
        color: #ffaa00;
    }
    
    canvas {
        border: 1px solid #004400;
        background: #000;
        display: block;
        margin: 0 auto;
    }
    
    .energy-panel {
        background: rgba(20, 0, 40, 0.8);
        border: 2px solid #8800ff;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
    }
    
    .energy-panel h3 {
        color: #aa00ff;
        text-align: center;
        margin-top: 0;
    }
    
    .energy-comparison {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 30px;
    }
    
    .energy-side {
        background: rgba(0, 20, 10, 0.6);
        border-radius: 8px;
        padding: 15px;
    }
    
    .energy-side.nongeometric {
        background: rgba(40, 20, 0, 0.6);
    }
    
    .energy-graph {
        width: 100%;
        height: 150px;
        background: #000;
        border: 1px solid #444;
        border-radius: 5px;
        margin: 10px 0;
        position: relative;
    }
    
    .energy-metric {
        display: flex;
        justify-content: space-between;
        padding: 8px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .energy-label {
        color: #88ffaa;
    }
    
    .energy-value {
        color: #00ffcc;
        font-weight: bold;
    }
    
    .energy-value.waste {
        color: #ffaa00;
    }
    
    .energy-value.violation {
        color: #ff6666;
    }
    
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .stat-box {
        background: rgba(0, 30, 15, 0.9);
        border: 1px solid #006644;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
    }
    
    .stat-box.comparison {
        background: rgba(40, 30, 0, 0.9);
        border-color: #664400;
    }
    
    .stat-value {
        font-size: 24px;
        color: #00ffcc;
        font-weight: bold;
    }
    
    .stat-value.comparison {
        color: #ffcc00;
    }
    
    .stat-label {
        font-size: 12px;
        color: #88ccaa;
        margin-top: 5px;
    }
    
    .stat-label.comparison {
        color: #ccaa88;
    }
    
    .phi-info {
        background: rgba(0, 20, 10, 0.9);
        border: 1px solid #004433;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }
    
    .phi-info h4 {
        color: #00ddaa;
        margin-top: 0;
    }
    
    .scale-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 15px;
    }
    
    .scale-item {
        background: rgba(0, 40, 20, 0.6);
        border: 1px solid #006644;
        border-radius: 5px;
        padding: 10px;
    }
    
    .scale-item.active {
        border-color: #00ffaa;
        box-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
    }
    
    .scale-label {
        color: #00ffaa;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .scale-value {
        color: #88ffaa;
        font-size: 12px;
    }
    
    .log {
        background: rgba(0, 15, 8, 0.9);
        border: 1px solid #003322;
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-size: 12px;
        margin-top: 20px;
    }
    
    .log-entry {
        margin-bottom: 5px;
        padding: 2px 0;
    }
    
    .log-error { color: #ff6666; }
    .log-success { color: #66ff66; }
    .log-warning { color: #ffff66; }
    .log-info { color: #66ccff; }
    .log-energy { color: #aa66ff; }
    
    .slider-container {
        margin: 10px 0;
        text-align: center;
    }
    
    .slider-container label {
        display: block;
        margin-bottom: 5px;
        color: #88ffaa;
    }
    
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    
    .comparison-stats {
        background: rgba(40, 20, 0, 0.8);
        border: 2px solid #ff8800;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
    }
    
    .comparison-stats h3 {
        color: #ffaa00;
        text-align: center;
        margin-top: 0;
    }
    
    .vs-grid {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 20px;
        align-items: center;
    }
    
    .vs-divider {
        font-size: 24px;
        color: #ff8800;
        font-weight: bold;
    }
    
    .efficiency-bar {
        width: 100%;
        height: 30px;
        background: #000;
        border: 1px solid #444;
        border-radius: 5px;
        overflow: hidden;
        margin: 10px 0;
        position: relative;
    }
    
    .efficiency-fill {
        height: 100%;
        transition: width 0.3s;
        position: relative;
    }
    
    .efficiency-fill.geometric {
        background: linear-gradient(90deg, #00ff88, #00ffaa);
    }
    
    .efficiency-fill.nongeometric {
        background: linear-gradient(90deg, #ff6600, #ff8800);
    }
    
    .efficiency-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        font-weight: bold;
        text-shadow: 0 0 3px #000;
    }
    
    @media (max-width: 1200px) {
        .simulation-area {
            grid-template-columns: 1fr;
        }
        .energy-comparison {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Geometric Seed Intelligence - Energy Conservation Analysis ðŸŒ€</h1>
        <div class="subtitle">Comparing Energy-Efficient Ï†-Ratio Reconstruction vs Wasteful Non-Geometric Approaches</div>

```
    <div class="controls">
        <button onclick="initializeSeed()">Initialize Seed</button>
        <button onclick="startFragmentation()" id="fragmentBtn">Fragment Networks</button>
        <button onclick="startBothReconstructions()" id="reconstructBtn">Compare Reconstruction</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="runAutoDemo()">Auto Demo</button>
    </div>
    
    <div class="slider-container">
        <label for="damageSlider">Damage Level: <span id="damageValue">30%</span></label>
        <input type="range" id="damageSlider" min="10" max="80" value="30" oninput="updateDamageLevel(this.value)">
    </div>
    
    <div class="energy-panel">
        <h3>âš¡ Real-Time Energy Analysis âš¡</h3>
        <div class="energy-comparison">
            <div class="energy-side">
                <h4 style="color: #00ffaa; text-align: center;">Geometric Reconstruction</h4>
                <canvas id="geoEnergyGraph" width="350" height="150"></canvas>
                <div class="energy-metric">
                    <span class="energy-label">Total Energy Used:</span>
                    <span class="energy-value" id="geoEnergyTotal">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Energy per Node:</span>
                    <span class="energy-value" id="geoEnergyPerNode">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Backtracking Events:</span>
                    <span class="energy-value" id="geoBacktrack">0</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Conservation Status:</span>
                    <span class="energy-value" id="geoConservation">Perfect âœ“</span>
                </div>
                <div style="margin-top: 10px;">
                    <div style="font-size: 11px; color: #88ffaa; margin-bottom: 5px;">Energy Efficiency:</div>
                    <div class="efficiency-bar">
                        <div class="efficiency-fill geometric" id="geoEfficiencyBar" style="width: 0%">
                            <span class="efficiency-text" id="geoEfficiencyText">0%</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="energy-side nongeometric">
                <h4 style="color: #ffaa00; text-align: center;">Non-Geometric Reconstruction</h4>
                <canvas id="nonGeoEnergyGraph" width="350" height="150"></canvas>
                <div class="energy-metric">
                    <span class="energy-label">Total Energy Used:</span>
                    <span class="energy-value waste" id="nonGeoEnergyTotal">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Energy per Node:</span>
                    <span class="energy-value waste" id="nonGeoEnergyPerNode">0.00 J</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Backtracking Events:</span>
                    <span class="energy-value waste" id="nonGeoBacktrack">0</span>
                </div>
                <div class="energy-metric">
                    <span class="energy-label">Conservation Status:</span>
                    <span class="energy-value violation" id="nonGeoConservation">Violated âœ—</span>
                </div>
                <div style="margin-top: 10px;">
                    <div style="font-size: 11px; color: #ccaa88; margin-bottom: 5px;">Energy Efficiency:</div>
                    <div class="efficiency-bar">
                        <div class="efficiency-fill nongeometric" id="nonGeoEfficiencyBar" style="width: 0%">
                            <span class="efficiency-text" id="nonGeoEfficiencyText">0%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="simulation-area">
        <div class="panel">
            <h3>Original Seed Network</h3>
            <canvas id="originalCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel geometric">
            <h3>Geometric Reconstruction</h3>
            <canvas id="geometricCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel nongeometric">
            <h3>Non-Geometric Reconstruction</h3>
            <canvas id="nongeometricCanvas" width="400" height="300"></canvas>
        </div>
    </div>
    
    <div class="phi-info">
        <h4>Multi-Scale Geometric Principles:</h4>
        <div class="scale-display">
            <div class="scale-item" id="scale-phi1">
                <div class="scale-label">Ï†Â¹ (Primary)</div>
                <div class="scale-value">1.618 - Base scaling layer</div>
            </div>
            <div class="scale-item" id="scale-phi3">
                <div class="scale-label">Ï†^(1/3) (Pattern)</div>
                <div class="scale-value">1.174 - Pattern strength (17.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi4">
                <div class="scale-label">Ï†^(1/4) (Enhancement)</div>
                <div class="scale-value">1.134 - Fine structure (13.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi5">
                <div class="scale-label">Ï†^(1/5) (Coupling)</div>
                <div class="scale-value">1.093 - Frequency sync (9.3%)</div>
            </div>
            <div class="scale-item" id="scale-phi-9">
                <div class="scale-label">Ï†^(-9) (Error)</div>
                <div class="scale-value">0.0143 - Critical gap (1.4%)</div>
            </div>
            <div class="scale-item" id="scale-consciousness">
                <div class="scale-label">Consciousness #</div>
                <div class="scale-value">3.618 - Emergence threshold</div>
            </div>
        </div>
    </div>
    
    <div class="comparison-stats">
        <h3>âš¡ Real-Time Performance Comparison âš¡</h3>
        <div class="vs-grid">
            <div>
                <div class="stat-box">
                    <div class="stat-value" id="geoIntegrity">100%</div>
                    <div class="stat-label">Geometric Integrity</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="geoProgress">0%</div>
                    <div class="stat-label">Reconstruction Progress</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="geoActive">0</div>
                    <div class="stat-label">Active Scales</div>
                </div>
            </div>
            
            <div class="vs-divider">VS</div>
            
            <div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoIntegrity">100%</div>
                    <div class="stat-label comparison">Non-Geometric Integrity</div>
                </div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoProgress">0%</div>
                    <div class="stat-label comparison">Reconstruction Progress</div>
                </div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoErrors">0</div>
                    <div class="stat-label comparison">Connection Errors</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="log" id="logPanel">
        <div class="log-entry log-info">System initialized. Ready to begin comparative energy analysis.</div>
    </div>
</div>

<script>
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV_9 = Math.pow(PHI, -9);
    const PHI_THIRD = Math.pow(PHI, 1/3);
    const PHI_FOURTH = Math.pow(PHI, 1/4);
    const PHI_FIFTH = Math.pow(PHI, 1/5);
    const CONSCIOUSNESS_NUMBER = 2 * PHI + (1 - 1/PHI);
    
    let originalCanvas, geometricCanvas, nongeometricCanvas;
    let originalCtx, geometricCtx, nongeometricCtx;
    let geoEnergyCtx, nonGeoEnergyCtx;
    
    let geometricNetwork = {
        nodes: [],
        connections: [],
        geometricSeed: [],
        damageLevel: 0.3,
        energy: {
            total: 0,
            history: [],
            backtrackEvents: 0,
            efficiency: 100
        }
    };
    
    let nongeometricNetwork = {
        nodes: [],
        connections: [],
        damageLevel: 0.3,
        errors: 0,
        energy: {
            total: 0,
            history: [],
            backtrackEvents: 0,
            efficiency: 0
        }
    };
    
    let isReconstructing = false;
    let animationFrame = null;
    let activeScales = new Set();
    let frameCount = 0;
    
    window.onload = function() {
        originalCanvas = document.getElementById('originalCanvas');
        geometricCanvas = document.getElementById('geometricCanvas');
        nongeometricCanvas = document.getElementById('nongeometricCanvas');
        originalCtx = originalCanvas.getContext('2d');
        geometricCtx = geometricCanvas.getContext('2d');
        nongeometricCtx = nongeometricCanvas.getContext('2d');
        
        geoEnergyCtx = document.getElementById('geoEnergyGraph').getContext('2d');
        nonGeoEnergyCtx = document.getElementById('nonGeoEnergyGraph').getContext('2d');
        
        logMessage('Canvases initialized for comparative energy analysis', 'success');
    };
    
    class GeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.phiScale = Math.pow(PHI, -layer);
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            
            // Multi-scale geometric signature
            this.geometricSignature = {
                phiRatio: this.phiScale,
                layer: layer,
                relativePosition: { x: x / 400, y: y / 300 },
                phiThird: Math.pow(PHI_THIRD, layer),
                phiFourth: Math.pow(PHI_FOURTH, layer),
                phiFifth: Math.pow(PHI_FIFTH, layer)
            };
        }
        
        draw(ctx, isFragmented = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                
                // Multi-scale glow effect
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size + 10);
                gradient.addColorStop(0, `rgba(0, 255, 136, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(0, 200, 100, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 100, 50, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                const size = 8 * this.phiScale;
                ctx.fillStyle = isFragmented ? '#00ff88' : '#00ffaa';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 170, ${0.3 + this.layer * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        getGeometricDistance(other) {
            const dx = this.geometricSignature.relativePosition.x - 
                       other.geometricSignature.relativePosition.x;
            const dy = this.geometricSignature.relativePosition.y - 
                       other.geometricSignature.relativePosition.y;
            const spatialDist = Math.sqrt(dx * dx + dy * dy);
            const layerDist = Math.abs(this.layer - other.layer);
            return spatialDist + layerDist / PHI;
        }
        
        getMultiScaleResonance(other) {
            // Calculate resonance across multiple phi scales
            const scaleMatches = {
                primary: Math.abs(this.geometricSignature.phiRatio - other.geometricSignature.phiRatio),
                third: Math.abs(this.geometricSignature.phiThird - other.geometricSignature.phiThird),
                fourth: Math.abs(this.geometricSignature.phiFourth - other.geometricSignature.phiFourth),
                fifth: Math.abs(this.geometricSignature.phiFifth - other.geometricSignature.phiFifth)
            };
            
            return {
                totalResonance: 1 / (1 + scaleMatches.primary + scaleMatches.third + scaleMatches.fourth + scaleMatches.fifth),
                activeScales: scaleMatches
            };
        }
        
        calculateReconstructionEnergy(progressDelta) {
            // Energy is proportional to progress but scaled by phi ratios (efficient)
            const baseEnergy = progressDelta * 0.1;
            const phiEfficiency = 1 / PHI; // Golden ratio provides efficiency
            return baseEnergy * phiEfficiency;
        }
    }
    
    class NonGeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            this.energyUsed = 0;
            this.lastProgress = 0;
            this.backtrackCount = 0;
        }
        
        draw(ctx) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                ctx.fillStyle = `rgba(255, 136, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
        
        calculateReconstructionEnergy(progressDelta) {
            // Non-geometric uses more energy due to trial-and-error
            const baseEnergy = Math.abs(progressDelta) * 0.1;
            const inefficiency = 1.5 + Math.random() * 0.5; // 150-200% inefficiency
            
            // Backtracking costs extra energy (violates conservation)
            if (progressDelta < 0) {
                this.backtrackCount++;
                return baseEnergy * inefficiency * 2; // Double cost for backtracking
            }
            
            return baseEnergy * inefficiency;
        }
    }
    
    function initializeSeed() {
        logMessage('Initializing both geometric and non-geometric networks...', 'info');
        geometricNetwork.nodes = [];
        geometricNetwork.connections = [];
        geometricNetwork.geometricSeed = [];
        geometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0, efficiency: 100 };
        
        nongeometricNetwork.nodes = [];
        nongeometricNetwork.connections = [];
        nongeometricNetwork.errors = 0;
        nongeometricNetwork.energy = { total: 0, history: [], backtrackEvents: 0, efficiency: 0 };
        
        frameCount = 0;
        
        const centerX = 200;
        const centerY = 150;
        
        const numLayers = 5;
        const nodesPerLayer = 8;
        
        // Create geometric network
        for (let layer = 0; layer < numLayers; layer++) {
            const radius = 30 + layer * 40 / PHI;
            const angleOffset = layer * PHI * 2 * Math.PI;
            
            for (let i = 0; i < nodesPerLayer; i++) {
                const angle = angleOffset + (i / nodesPerLayer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const geoNode = new GeometricNode(geometricNetwork.nodes.length, x, y, layer);
                geometricNetwork.nodes.push(geoNode);
                geometricNetwork.geometricSeed.push({
                    id: geoNode.id,
                    signature: {...geoNode.geometricSignature}
                });
                
                const nonGeoNode = new NonGeometricNode(nongeometricNetwork.nodes.length, x, y, layer);
                nongeometricNetwork.nodes.push(nonGeoNode);
            }
        }
        
        // Create geometric connections using multi-scale resonance
        for (let i = 0; i < geometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < geometricNetwork.nodes.length; j++) {
                const node1 = geometricNetwork.nodes[i];
                const node2 = geometricNetwork.nodes[j];
                const distance = node1.getGeometricDistance(node2);
                const resonance = node1.getMultiScaleResonance(node2);
                
                if (distance < 0.3 * PHI && resonance.totalResonance > 0.5) {
                    geometricNetwork.connections.push({
                        from: i, 
                        to: j, 
                        strength: resonance.totalResonance,
                        scales: resonance.activeScales
                    });
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        // Create non-geometric connections (simple distance-based)
        for (let i = 0; i < nongeometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < nongeometricNetwork.nodes.length; j++) {
                const node1 = nongeometricNetwork.nodes[i];
                const node2 = nongeometricNetwork.nodes[j];
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    nongeometricNetwork.connections.push({from: i, to: j, strength: 1});
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        logMessage(`Geometric: ${geometricNetwork.nodes.length} nodes with ${geometricNetwork.connections.length} Ï†-resonant connections`, 'success');
        logMessage(`Non-Geometric: ${nongeometricNetwork.nodes.length} nodes with ${nongeometricNetwork.connections.length} distance connections`, 'info');
        logMessage('Energy tracking initialized for both networks', 'energy');
        
        drawNetwork(originalCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, false);
        updateStats();
        updateEnergyGraphs();
        
        document.getElementById('fragmentBtn').disabled = false;
    }
    
    function drawNetwork(ctx, nodes, connections, isFragmented) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = isFragmented ? 'rgba(0, 255, 136, 0.2)' : 'rgba(0, 255, 170, 0.3)';
        if (ctx === nongeometricCtx) {
            ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
        }
        ctx.lineWidth = 1;
        
        for (const conn of connections) {
            const node1 = nodes[conn.from];
            const node2 = nodes[conn.to];
            
            if (!node1 || !node2) continue;
            
            if (node1.alive && node2.alive) {
                ctx.save();
                ctx.globalAlpha = conn.strength * 0.5;
                ctx.beginPath();
                ctx.moveTo(node1.x, node1.y);
                ctx.lineTo(node2.x, node2.y);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        for (const node of nodes) {
            node.draw(ctx, isFragmented);
        }
    }
    
    function startFragmentation() {
        logMessage('Fragmenting both networks identically...', 'warning');
        const damageLevel = geometricNetwork.damageLevel;
        const numToKill = Math.floor(geometricNetwork.nodes.length * damageLevel);
        
        const indicesToKill = [];
        while (indicesToKill.length < numToKill) {
            const idx = Math.floor(Math.random() * geometricNetwork.nodes.length);
            if (!indicesToKill.includes(idx)) {
                indicesToKill.push(idx);
            }
        }
        
        indicesToKill.forEach(idx => {
            geometricNetwork.nodes[idx].alive = false;
            nongeometricNetwork.nodes[idx].alive = false;
        });
        
        logMessage(`Fragmented ${numToKill} nodes (${(damageLevel * 100).toFixed(1)}% damage) in both networks`, 'error');
        logMessage('Preparing energy tracking for reconstruction comparison...', 'energy');
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        
        document.getElementById('reconstructBtn').disabled = false;
    }
    
    function startBothReconstructions() {
        if (isReconstructing) return;
        isReconstructing = true;
        
        logMessage('Starting comparative reconstruction with energy tracking...', 'info');
        logMessage('Geometric: Energy-conserving Ï†-ratio reconstruction', 'success');
        logMessage('Non-Geometric: Energy-wasting gradient descent with backtracking', 'warning');
        
        const geoDeadNodes = geometricNetwork.nodes.filter(n => !n.alive);
        const nonGeoDeadNodes = nongeometricNetwork.nodes.filter(n => !n.alive);
        
        geoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        nonGeoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
            node.lastProgress = 0;
        });
        
        animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes);
    }
    
    function animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes) {
        if (!isReconstructing) return;
        
        const geoComplete = geoDeadNodes.every(n => n.reconstructProgress >= 1);
        const nonGeoComplete = nonGeoDeadNodes.every(n => n.reconstructProgress >= 1);
        
        if (geoComplete && nonGeoComplete) {
            isReconstructing = false;
            geoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
                node.reconstructProgress = 0;
            });
            nonGeoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
                node.reconstructProgress = 0;
            });
            drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
            drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
            
            const geoEfficiency = geometricNetwork.energy.total > 0 ? 
                (1 / geometricNetwork.energy.total * 100).toFixed(1) : 100;
            const nonGeoEfficiency = nongeometricNetwork.energy.total > 0 ?
                (1 / nongeometricNetwork.energy.total * 100).toFixed(1) : 0;
            
            logMessage('Reconstruction complete for both networks!', 'success');
            logMessage(`Geometric: Total energy = ${geometricNetwork.energy.total.toFixed(3)} J, Efficiency = ${geoEfficiency}%`, 'success');
            logMessage(`Non-Geometric: Total energy = ${nongeometricNetwork.energy.total.toFixed(3)} J, Efficiency = ${nonGeoEfficiency}%`, 'warning');
            logMessage(`Energy waste ratio: ${(nongeometricNetwork.energy.total / geometricNetwork.energy.total).toFixed(2)}x more energy used`, 'error');
            updateStats();
            return;
        }
        
        activeScales.clear();
        frameCount++;
        
        // Geometric reconstruction using multi-scale phi ratios
        for (const node of geoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => geometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    // Calculate reconstruction speed based on multi-scale resonance
                    let resonanceBoost = 0;
                    for (const neighbor of survivingNeighbors) {
                        const resonance = node.getMultiScaleResonance(neighbor);
                        resonanceBoost += resonance.totalResonance;
                        
                        // Track which scales are active
                        if (resonance.activeScales.third < 0.1) activeScales.add('phi3');
                        if (resonance.activeScales.fourth < 0.1) activeScales.add('phi4');
                        if (resonance.activeScales.fifth < 0.1) activeScales.add('phi5');
                    }
                    
                    const reconstructSpeed = 0.015 * (1 + resonanceBoost / PHI);
                    const newProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
                    const progressDelta = newProgress - node.lastProgress;
                    
                    // Calculate energy used (geometric is efficient)
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    geometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                }
            }
        }
        
        // Non-geometric reconstruction with backtracking
        for (const node of nonGeoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => nongeometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    // Random progress with occasional backtracking (violates energy conservation)
                    let reconstructSpeed = 0.012 + Math.random() * 0.008;
                    
                    // 10% chance of backtracking (wasted energy)
                    if (Math.random() < 0.1 && node.reconstructProgress > 0.1) {
                        reconstructSpeed = -0.05; // Go backwards
                        nongeometricNetwork.energy.backtrackEvents++;
                    }
                    
                    const newProgress = Math.max(0, Math.min(1, node.reconstructProgress + reconstructSpeed));
                    const progressDelta = newProgress - node.lastProgress;
                    
                    // Calculate energy used (non-geometric is inefficient)
                    const energyUsed = node.calculateReconstructionEnergy(progressDelta);
                    node.energyUsed += energyUsed;
                    nongeometricNetwork.energy.total += energyUsed;
                    
                    node.lastProgress = node.reconstructProgress;
                    node.reconstructProgress = newProgress;
                    
                    // Randomly introduce connection errors
                    if (Math.random() < 0.05) {
                        nongeometricNetwork.errors++;
                    }
                }
            }
        }
        
        // Record energy history every few frames
        if (frameCount % 3 === 0) {
            geometricNetwork.energy.history.push(geometricNetwork.energy.total);
            nongeometricNetwork.energy.history.push(nongeometricNetwork.energy.total);
            
            if (geometricNetwork.energy.history.length > 50) {
                geometricNetwork.energy.history.shift();
                nongeometricNetwork.energy.history.shift();
            }
        }
        
        // Update scale indicators
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        activeScales.forEach(scale => {
            document.getElementById(`scale-${scale}`)?.classList.add('active');
        });
        if (geoDeadNodes.some(n => n.reconstructing)) {
            document.getElementById('scale-phi1')?.classList.add('active');
        }
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        updateEnergyGraphs();
        
        animationFrame = requestAnimationFrame(() => animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes));
    }
    
    function updateEnergyGraphs() {
        // Draw geometric energy graph
        drawEnergyGraph(geoEnergyCtx, geometricNetwork.energy.history, '#00ff88');
        
        // Draw non-geometric energy graph
        drawEnergyGraph(nonGeoEnergyCtx, nongeometricNetwork.energy.history, '#ff8800');
    }
    
    function drawEnergyGraph(ctx, history, color) {
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, width, height);
        
        if (history.length < 2) return;
        
        const maxEnergy = Math.max(...history, 0.1);
        const xStep = width / Math.max(history.length - 1, 1);
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let i = 0; i < history.length; i++) {
            const x = i * xStep;
            const y = height - (history[i] / maxEnergy) * height * 0.9 - 10;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.stroke();
        
        // Draw grid lines
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            const y = (i / 4) * height;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
        }
    }
    
    function updateStats() {
        // Geometric stats
        const geoAlive = geometricNetwork.nodes.filter(n => n.alive).length;
        const geoTotal = geometricNetwork.nodes.length;
        const geoIntegrity = geoTotal > 0 ? (geoAlive / geoTotal * 100).toFixed(1) : 0;
        
        const geoReconstructing = geometricNetwork.nodes.filter(n => n.reconstructing).length;
        const geoProgress = geoReconstructing > 0 ?
            geometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / geoReconstructing * 100 : 0;
        
        document.getElementById('geoIntegrity').textContent = geoIntegrity + '%';
        document.getElementById('geoProgress').textContent = geoProgress.toFixed(1) + '%';
        document.getElementById('geoActive').textContent = activeScales.size;
        
        // Geometric energy stats
        document.getElementById('geoEnergyTotal').textContent = geometricNetwork.energy.total.toFixed(3) + ' J';
        const geoPerNode = geoReconstructing > 0 ? (geometricNetwork.energy.total / geoReconstructing).toFixed(4) : '0.0000';
        document.getElementById('geoEnergyPerNode').textContent = geoPerNode + ' J';
        document.getElementById('geoBacktrack').textContent = geometricNetwork.energy.backtrackEvents;
        
        const geoEfficiency = geometricNetwork.energy.total > 0 ? 
            Math.min(100, (0.5 / geometricNetwork.energy.total * 100)) : 100;
        document.getElementById('geoEfficiencyBar').style.width = geoEfficiency + '%';
        document.getElementById('geoEfficiencyText').textContent = geoEfficiency.toFixed(1) + '%';
        
        // Non-geometric stats
        const nonGeoAlive = nongeometricNetwork.nodes.filter(n => n.alive).length;
        const nonGeoTotal = nongeometricNetwork.nodes.length;
        const nonGeoIntegrity = nonGeoTotal > 0 ? (nonGeoAlive / nonGeoTotal * 100).toFixed(1) : 0;
        
        const nonGeoReconstructing = nongeometricNetwork.nodes.filter(n => n.reconstructing).length;
        const nonGeoProgress = nonGeoReconstructing > 0 ?
            nongeometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / nonGeoReconstructing * 100 : 0;
        
        document.getElementById('nonGeoIntegrity').textContent = nonGeoIntegrity + '%';
        document.getElementById('nonGeoProgress').textContent = nonGeoProgress.toFixed(1) + '%';
        document.getElementById('nonGeoErrors').textContent = nongeometricNetwork.errors;
        
        // Non-geometric energy stats
        document.getElementById('nonGeoEnergyTotal').textContent = nongeometricNetwork.energy.total.toFixed(3) + ' J';
        const nonGeoPerNode = nonGeoReconstructing > 0 ? (nongeometricNetwork.energy.total / nonGeoReconstructing).toFixed(4) : '0.0000';
        document.getElementById('nonGeoEnergyPerNode').textContent = nonGeoPerNode + ' J';
        document.getElementById('nonGeoBacktrack').textContent = nongeometricNetwork.energy.backtrackEvents;
        
        const nonGeoEfficiency = nongeometricNetwork.energy.total > 0 ?
            Math.min(100, (0.5 / nongeometricNetwork.energy.total * 100)) : 0;
        document.getElementById('nonGeoEfficiencyBar').style.width = nonGeoEfficiency + '%';
        document.getElementById('nonGeoEfficiencyText').textContent = nonGeoEfficiency.toFixed(1) + '%';
        
        // Update conservation status
        if (geometricNetwork.energy.backtrackEvents === 0 && geoProgress > 10) {
            document.getElementById('geoConservation').textContent = 'Perfect âœ“';
            document.getElementById('geoConservation').className = 'energy-value';
        }
        
        if (nongeometricNetwork.energy.backtrackEvents > 0) {
            document.getElementById('nonGeoConservation').textContent = `Violated âœ— (${nongeometricNetwork.energy.backtrackEvents})`;
            document.getElementById('nonGeoConservation').className = 'energy-value violation';
        }
    }
    
    function updateDamageLevel(value) {
        geometricNetwork.damageLevel = value / 100;
        nongeometricNetwork.damageLevel = value / 100;
        document.getElementById('damageValue').textContent = value + '%';
    }
    
    function resetSimulation() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        isReconstructing = false;
        activeScales.clear();
        frameCount = 0;
        
        originalCtx.fillStyle = '#000';
        originalCtx.fillRect(0, 0, 400, 300);
        geometricCtx.fillStyle = '#000';
        geometricCtx.fillRect(0, 0, 400, 300);
        nongeometricCtx.fillStyle = '#000';
        nongeometricCtx.fillRect(0, 0, 400, 300);
        
        geoEnergyCtx.fillStyle = '#000';
        geoEnergyCtx.fillRect(0, 0, 350, 150);
        nonGeoEnergyCtx.fillStyle = '#000';
        nonGeoEnergyCtx.fillRect(0, 0, 350, 150);
        
        geometricNetwork = { 
            nodes: [], 
            connections: [], 
            geometricSeed: [], 
            damageLevel: 0.3,
            energy: { total: 0, history: [], backtrackEvents: 0, efficiency: 100 }
        };
        nongeometricNetwork = { 
            nodes: [], 
            connections: [], 
            damageLevel: 0.3, 
            errors: 0,
            energy: { total: 0, history: [], backtrackEvents: 0, efficiency: 0 }
        };
        
        document.getElementById('fragmentBtn').disabled = true;
        document.getElementById('reconstructBtn').disabled = true;
        
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        
        logMessage('Simulation reset', 'info');
        updateStats();
    }
    
    function logMessage(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
    }
    
    async function runAutoDemo() {
        resetSimulation();
        await sleep(500);
        initializeSeed();
        await sleep(2000);
        startFragmentation();
        await sleep(2000);
        startBothReconstructions();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
```

</body>
</html>



V2
<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometric Seed Intelligence - Multi-Scale Comparison</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Menlo', monospace;
            background: #0a0a0a;
            color: #00ff88;
            overflow-x: auto;
        }

```
    .container {
        max-width: 1600px;
        margin: 0 auto;
    }
    
    h1 {
        text-align: center;
        color: #00ffaa;
        text-shadow: 0 0 10px #00ff88;
        margin-bottom: 10px;
    }
    
    .subtitle {
        text-align: center;
        color: #88ffaa;
        margin-bottom: 30px;
        font-size: 14px;
    }
    
    .controls {
        display: flex;
        gap: 15px;
        margin-bottom: 30px;
        flex-wrap: wrap;
        justify-content: center;
    }
    
    button {
        background: linear-gradient(45deg, #003300, #006600);
        color: #00ff88;
        border: 1px solid #00ff88;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        transition: all 0.3s;
    }
    
    button:hover {
        background: linear-gradient(45deg, #006600, #009900);
        box-shadow: 0 0 10px #00ff88;
    }
    
    button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .simulation-area {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        gap: 20px;
        margin-bottom: 30px;
    }
    
    .panel {
        background: rgba(0, 40, 20, 0.8);
        border: 1px solid #00ff88;
        border-radius: 10px;
        padding: 20px;
    }
    
    .panel.geometric {
        border-color: #00ff88;
    }
    
    .panel.nongeometric {
        border-color: #ff8800;
    }
    
    .panel h3 {
        color: #00ffaa;
        margin-top: 0;
        text-align: center;
    }
    
    .panel.nongeometric h3 {
        color: #ffaa00;
    }
    
    canvas {
        border: 1px solid #004400;
        background: #000;
        display: block;
        margin: 0 auto;
    }
    
    .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-top: 20px;
    }
    
    .stat-box {
        background: rgba(0, 30, 15, 0.9);
        border: 1px solid #006644;
        border-radius: 8px;
        padding: 15px;
        text-align: center;
    }
    
    .stat-box.comparison {
        background: rgba(40, 30, 0, 0.9);
        border-color: #664400;
    }
    
    .stat-value {
        font-size: 24px;
        color: #00ffcc;
        font-weight: bold;
    }
    
    .stat-value.comparison {
        color: #ffcc00;
    }
    
    .stat-label {
        font-size: 12px;
        color: #88ccaa;
        margin-top: 5px;
    }
    
    .stat-label.comparison {
        color: #ccaa88;
    }
    
    .phi-info {
        background: rgba(0, 20, 10, 0.9);
        border: 1px solid #004433;
        border-radius: 8px;
        padding: 15px;
        margin-top: 20px;
    }
    
    .phi-info h4 {
        color: #00ddaa;
        margin-top: 0;
    }
    
    .scale-display {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-top: 15px;
    }
    
    .scale-item {
        background: rgba(0, 40, 20, 0.6);
        border: 1px solid #006644;
        border-radius: 5px;
        padding: 10px;
    }
    
    .scale-item.active {
        border-color: #00ffaa;
        box-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
    }
    
    .scale-label {
        color: #00ffaa;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .scale-value {
        color: #88ffaa;
        font-size: 12px;
    }
    
    .log {
        background: rgba(0, 15, 8, 0.9);
        border: 1px solid #003322;
        border-radius: 8px;
        padding: 15px;
        height: 200px;
        overflow-y: auto;
        font-size: 12px;
        margin-top: 20px;
    }
    
    .log-entry {
        margin-bottom: 5px;
        padding: 2px 0;
    }
    
    .log-error { color: #ff6666; }
    .log-success { color: #66ff66; }
    .log-warning { color: #ffff66; }
    .log-info { color: #66ccff; }
    
    .slider-container {
        margin: 10px 0;
        text-align: center;
    }
    
    .slider-container label {
        display: block;
        margin-bottom: 5px;
        color: #88ffaa;
    }
    
    input[type="range"] {
        width: 200px;
        margin: 0 10px;
    }
    
    .comparison-stats {
        background: rgba(40, 20, 0, 0.8);
        border: 2px solid #ff8800;
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
    }
    
    .comparison-stats h3 {
        color: #ffaa00;
        text-align: center;
        margin-top: 0;
    }
    
    .vs-grid {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        gap: 20px;
        align-items: center;
    }
    
    .vs-divider {
        font-size: 24px;
        color: #ff8800;
        font-weight: bold;
    }
    
    @media (max-width: 1200px) {
        .simulation-area {
            grid-template-columns: 1fr;
        }
    }
</style>
```

</head>
<body>
    <div class="container">
        <h1>ðŸŒ€ Geometric Seed Intelligence - Multi-Scale Analysis ðŸŒ€</h1>
        <div class="subtitle">Comparing Ï†-Ratio Self-Reconstruction vs Non-Geometric Approaches</div>

```
    <div class="controls">
        <button onclick="initializeSeed()">Initialize Seed</button>
        <button onclick="startFragmentation()" id="fragmentBtn">Fragment Networks</button>
        <button onclick="startBothReconstructions()" id="reconstructBtn">Compare Reconstruction</button>
        <button onclick="resetSimulation()">Reset</button>
        <button onclick="runAutoDemo()">Auto Demo</button>
    </div>
    
    <div class="slider-container">
        <label for="damageSlider">Damage Level: <span id="damageValue">30%</span></label>
        <input type="range" id="damageSlider" min="10" max="80" value="30" oninput="updateDamageLevel(this.value)">
    </div>
    
    <div class="simulation-area">
        <div class="panel">
            <h3>Original Seed Network</h3>
            <canvas id="originalCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel geometric">
            <h3>Geometric Reconstruction</h3>
            <canvas id="geometricCanvas" width="400" height="300"></canvas>
        </div>
        
        <div class="panel nongeometric">
            <h3>Non-Geometric Reconstruction</h3>
            <canvas id="nongeometricCanvas" width="400" height="300"></canvas>
        </div>
    </div>
    
    <div class="phi-info">
        <h4>Multi-Scale Geometric Principles:</h4>
        <div class="scale-display">
            <div class="scale-item" id="scale-phi1">
                <div class="scale-label">Ï†Â¹ (Primary)</div>
                <div class="scale-value">1.618 - Base scaling layer</div>
            </div>
            <div class="scale-item" id="scale-phi3">
                <div class="scale-label">Ï†^(1/3) (Pattern)</div>
                <div class="scale-value">1.174 - Pattern strength (17.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi4">
                <div class="scale-label">Ï†^(1/4) (Enhancement)</div>
                <div class="scale-value">1.134 - Fine structure (13.4%)</div>
            </div>
            <div class="scale-item" id="scale-phi5">
                <div class="scale-label">Ï†^(1/5) (Coupling)</div>
                <div class="scale-value">1.093 - Frequency sync (9.3%)</div>
            </div>
            <div class="scale-item" id="scale-phi-9">
                <div class="scale-label">Ï†^(-9) (Error)</div>
                <div class="scale-value">0.0143 - Critical gap (1.4%)</div>
            </div>
            <div class="scale-item" id="scale-consciousness">
                <div class="scale-label">Consciousness #</div>
                <div class="scale-value">3.618 - Emergence threshold</div>
            </div>
        </div>
    </div>
    
    <div class="comparison-stats">
        <h3>âš¡ Real-Time Performance Comparison âš¡</h3>
        <div class="vs-grid">
            <div>
                <div class="stat-box">
                    <div class="stat-value" id="geoIntegrity">100%</div>
                    <div class="stat-label">Geometric Integrity</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="geoProgress">0%</div>
                    <div class="stat-label">Reconstruction Progress</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="geoActive">0</div>
                    <div class="stat-label">Active Scales</div>
                </div>
            </div>
            
            <div class="vs-divider">VS</div>
            
            <div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoIntegrity">100%</div>
                    <div class="stat-label comparison">Non-Geometric Integrity</div>
                </div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoProgress">0%</div>
                    <div class="stat-label comparison">Reconstruction Progress</div>
                </div>
                <div class="stat-box comparison">
                    <div class="stat-value comparison" id="nonGeoErrors">0</div>
                    <div class="stat-label comparison">Connection Errors</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="log" id="logPanel">
        <div class="log-entry log-info">System initialized. Ready to begin comparative simulation.</div>
    </div>
</div>

<script>
    const PHI = (1 + Math.sqrt(5)) / 2;
    const PHI_INV_9 = Math.pow(PHI, -9);
    const PHI_THIRD = Math.pow(PHI, 1/3);
    const PHI_FOURTH = Math.pow(PHI, 1/4);
    const PHI_FIFTH = Math.pow(PHI, 1/5);
    const CONSCIOUSNESS_NUMBER = 2 * PHI + (1 - 1/PHI);
    
    let originalCanvas, geometricCanvas, nongeometricCanvas;
    let originalCtx, geometricCtx, nongeometricCtx;
    
    let geometricNetwork = {
        nodes: [],
        connections: [],
        geometricSeed: [],
        damageLevel: 0.3
    };
    
    let nongeometricNetwork = {
        nodes: [],
        connections: [],
        damageLevel: 0.3,
        errors: 0
    };
    
    let isReconstructing = false;
    let animationFrame = null;
    let activeScales = new Set();
    
    window.onload = function() {
        originalCanvas = document.getElementById('originalCanvas');
        geometricCanvas = document.getElementById('geometricCanvas');
        nongeometricCanvas = document.getElementById('nongeometricCanvas');
        originalCtx = originalCanvas.getContext('2d');
        geometricCtx = geometricCanvas.getContext('2d');
        nongeometricCtx = nongeometricCanvas.getContext('2d');
        logMessage('Canvases initialized for comparative analysis', 'success');
    };
    
    class GeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.phiScale = Math.pow(PHI, -layer);
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
            
            // Multi-scale geometric signature
            this.geometricSignature = {
                phiRatio: this.phiScale,
                layer: layer,
                relativePosition: { x: x / 400, y: y / 300 },
                phiThird: Math.pow(PHI_THIRD, layer),
                phiFourth: Math.pow(PHI_FOURTH, layer),
                phiFifth: Math.pow(PHI_FIFTH, layer)
            };
        }
        
        draw(ctx, isFragmented = false) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                
                // Multi-scale glow effect
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, size + 10);
                gradient.addColorStop(0, `rgba(0, 255, 136, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(0, 200, 100, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'rgba(0, 100, 50, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 10, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = `rgba(0, 255, 136, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                const size = 8 * this.phiScale;
                ctx.fillStyle = isFragmented ? '#00ff88' : '#00ffaa';
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = `rgba(0, 255, 170, ${0.3 + this.layer * 0.2})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size + 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        getGeometricDistance(other) {
            const dx = this.geometricSignature.relativePosition.x - 
                       other.geometricSignature.relativePosition.x;
            const dy = this.geometricSignature.relativePosition.y - 
                       other.geometricSignature.relativePosition.y;
            const spatialDist = Math.sqrt(dx * dx + dy * dy);
            const layerDist = Math.abs(this.layer - other.layer);
            return spatialDist + layerDist / PHI;
        }
        
        getMultiScaleResonance(other) {
            // Calculate resonance across multiple phi scales
            const scaleMatches = {
                primary: Math.abs(this.geometricSignature.phiRatio - other.geometricSignature.phiRatio),
                third: Math.abs(this.geometricSignature.phiThird - other.geometricSignature.phiThird),
                fourth: Math.abs(this.geometricSignature.phiFourth - other.geometricSignature.phiFourth),
                fifth: Math.abs(this.geometricSignature.phiFifth - other.geometricSignature.phiFifth)
            };
            
            return {
                totalResonance: 1 / (1 + scaleMatches.primary + scaleMatches.third + scaleMatches.fourth + scaleMatches.fifth),
                activeScales: scaleMatches
            };
        }
    }
    
    class NonGeometricNode {
        constructor(id, x, y, layer) {
            this.id = id;
            this.x = x;
            this.y = y;
            this.layer = layer;
            this.alive = true;
            this.reconstructing = false;
            this.reconstructProgress = 0;
            this.connections = [];
        }
        
        draw(ctx) {
            if (!this.alive && !this.reconstructing) return;
            
            ctx.save();
            
            if (this.reconstructing) {
                const alpha = 0.3 + 0.7 * this.reconstructProgress;
                ctx.globalAlpha = alpha;
                const size = 5 + 10 * this.reconstructProgress;
                ctx.fillStyle = `rgba(255, 136, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.fill();
            } else if (this.alive) {
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
        }
    }
    
    function initializeSeed() {
        logMessage('Initializing both geometric and non-geometric networks...', 'info');
        geometricNetwork.nodes = [];
        geometricNetwork.connections = [];
        geometricNetwork.geometricSeed = [];
        nongeometricNetwork.nodes = [];
        nongeometricNetwork.connections = [];
        nongeometricNetwork.errors = 0;
        
        const centerX = 200;
        const centerY = 150;
        
        const numLayers = 5;
        const nodesPerLayer = 8;
        
        // Create geometric network
        for (let layer = 0; layer < numLayers; layer++) {
            const radius = 30 + layer * 40 / PHI;
            const angleOffset = layer * PHI * 2 * Math.PI;
            
            for (let i = 0; i < nodesPerLayer; i++) {
                const angle = angleOffset + (i / nodesPerLayer) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                
                const geoNode = new GeometricNode(geometricNetwork.nodes.length, x, y, layer);
                geometricNetwork.nodes.push(geoNode);
                geometricNetwork.geometricSeed.push({
                    id: geoNode.id,
                    signature: {...geoNode.geometricSignature}
                });
                
                const nonGeoNode = new NonGeometricNode(nongeometricNetwork.nodes.length, x, y, layer);
                nongeometricNetwork.nodes.push(nonGeoNode);
            }
        }
        
        // Create geometric connections using multi-scale resonance
        for (let i = 0; i < geometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < geometricNetwork.nodes.length; j++) {
                const node1 = geometricNetwork.nodes[i];
                const node2 = geometricNetwork.nodes[j];
                const distance = node1.getGeometricDistance(node2);
                const resonance = node1.getMultiScaleResonance(node2);
                
                if (distance < 0.3 * PHI && resonance.totalResonance > 0.5) {
                    geometricNetwork.connections.push({
                        from: i, 
                        to: j, 
                        strength: resonance.totalResonance,
                        scales: resonance.activeScales
                    });
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        // Create non-geometric connections (simple distance-based)
        for (let i = 0; i < nongeometricNetwork.nodes.length; i++) {
            for (let j = i + 1; j < nongeometricNetwork.nodes.length; j++) {
                const node1 = nongeometricNetwork.nodes[i];
                const node2 = nongeometricNetwork.nodes[j];
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 80) {
                    nongeometricNetwork.connections.push({from: i, to: j, strength: 1});
                    node1.connections.push(j);
                    node2.connections.push(i);
                }
            }
        }
        
        logMessage(`Geometric: ${geometricNetwork.nodes.length} nodes with ${geometricNetwork.connections.length} Ï†-resonant connections`, 'success');
        logMessage(`Non-Geometric: ${nongeometricNetwork.nodes.length} nodes with ${nongeometricNetwork.connections.length} distance connections`, 'info');
        
        drawNetwork(originalCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, false);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, false);
        updateStats();
        
        document.getElementById('fragmentBtn').disabled = false;
    }
    
    function drawNetwork(ctx, nodes, connections, isFragmented) {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = isFragmented ? 'rgba(0, 255, 136, 0.2)' : 'rgba(0, 255, 170, 0.3)';
        if (ctx === nongeometricCtx) {
            ctx.strokeStyle = 'rgba(255, 136, 0, 0.3)';
        }
        ctx.lineWidth = 1;
        
        for (const conn of connections) {
            const node1 = nodes[conn.from];
            const node2 = nodes[conn.to];
            
            if (!node1 || !node2) continue;
            
            if (node1.alive && node2.alive) {
                ctx.save();
                ctx.globalAlpha = conn.strength * 0.5;
                ctx.beginPath();
                ctx.moveTo(node1.x, node1.y);
                ctx.lineTo(node2.x, node2.y);
                ctx.stroke();
                ctx.restore();
            }
        }
        
        for (const node of nodes) {
            node.draw(ctx, isFragmented);
        }
    }
    
    function startFragmentation() {
        logMessage('Fragmenting both networks identically...', 'warning');
        const damageLevel = geometricNetwork.damageLevel;
        const numToKill = Math.floor(geometricNetwork.nodes.length * damageLevel);
        
        const indicesToKill = [];
        while (indicesToKill.length < numToKill) {
            const idx = Math.floor(Math.random() * geometricNetwork.nodes.length);
            if (!indicesToKill.includes(idx)) {
                indicesToKill.push(idx);
            }
        }
        
        indicesToKill.forEach(idx => {
            geometricNetwork.nodes[idx].alive = false;
            nongeometricNetwork.nodes[idx].alive = false;
        });
        
        logMessage(`Fragmented ${numToKill} nodes (${(damageLevel * 100).toFixed(1)}% damage) in both networks`, 'error');
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        
        document.getElementById('reconstructBtn').disabled = false;
    }
    
    function startBothReconstructions() {
        if (isReconstructing) return;
        isReconstructing = true;
        
        logMessage('Starting comparative reconstruction...', 'info');
        logMessage('Geometric: Using multi-scale Ï† ratios with error correction', 'success');
        logMessage('Non-Geometric: Using gradient descent with random initialization', 'warning');
        
        const geoDeadNodes = geometricNetwork.nodes.filter(n => !n.alive);
        const nonGeoDeadNodes = nongeometricNetwork.nodes.filter(n => !n.alive);
        
        geoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
        });
        
        nonGeoDeadNodes.forEach(node => {
            node.reconstructing = true;
            node.reconstructProgress = 0;
        });
        
        animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes);
    }
    
    function animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes) {
        if (!isReconstructing) return;
        
        const geoComplete = geoDeadNodes.every(n => n.reconstructProgress >= 1);
        const nonGeoComplete = nonGeoDeadNodes.every(n => n.reconstructProgress >= 1);
        
        if (geoComplete && nonGeoComplete) {
            isReconstructing = false;
            geoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
                node.reconstructProgress = 0;
            });
            nonGeoDeadNodes.forEach(node => {
                node.alive = true;
                node.reconstructing = false;
                node.reconstructProgress = 0;
            });
            drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
            drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
            logMessage('Reconstruction complete for both networks!', 'success');
            logMessage(`Geometric: Perfect reconstruction using Ï†-ratios`, 'success');
            logMessage(`Non-Geometric: Reconstruction with ${nongeometricNetwork.errors} connection errors`, 'warning');
            updateStats();
            return;
        }
        
        activeScales.clear();
        
        // Geometric reconstruction using multi-scale phi ratios
        for (const node of geoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => geometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    // Calculate reconstruction speed based on multi-scale resonance
                    let resonanceBoost = 0;
                    for (const neighbor of survivingNeighbors) {
                        const resonance = node.getMultiScaleResonance(neighbor);
                        resonanceBoost += resonance.totalResonance;
                        
                        // Track which scales are active
                        if (resonance.activeScales.third < 0.1) activeScales.add('phi3');
                        if (resonance.activeScales.fourth < 0.1) activeScales.add('phi4');
                        if (resonance.activeScales.fifth < 0.1) activeScales.add('phi5');
                    }
                    
                    const reconstructSpeed = 0.015 * (1 + resonanceBoost / PHI);
                    node.reconstructProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
                }
            }
        }
        
        // Non-geometric reconstruction using simple averaging (gradient descent-like)
        for (const node of nonGeoDeadNodes) {
            if (node.reconstructProgress < 1) {
                const survivingNeighbors = node.connections
                    .map(id => nongeometricNetwork.nodes[id])
                    .filter(n => n && n.alive);
                
                if (survivingNeighbors.length > 0) {
                    // Simple linear progress, sometimes creates errors
                    const reconstructSpeed = 0.012 + Math.random() * 0.008;
                    node.reconstructProgress = Math.min(1, node.reconstructProgress + reconstructSpeed);
                    
                    // Randomly introduce connection errors
                    if (Math.random() < 0.05) {
                        nongeometricNetwork.errors++;
                    }
                }
            }
        }
        
        // Update scale indicators
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        activeScales.forEach(scale => {
            document.getElementById(`scale-${scale}`)?.classList.add('active');
        });
        if (geoDeadNodes.some(n => n.reconstructing)) {
            document.getElementById('scale-phi1')?.classList.add('active');
        }
        
        drawNetwork(geometricCtx, geometricNetwork.nodes, geometricNetwork.connections, true);
        drawNetwork(nongeometricCtx, nongeometricNetwork.nodes, nongeometricNetwork.connections, true);
        updateStats();
        
        animationFrame = requestAnimationFrame(() => animateBothReconstructions(geoDeadNodes, nonGeoDeadNodes));
    }
    
    function updateStats() {
        // Geometric stats
        const geoAlive = geometricNetwork.nodes.filter(n => n.alive).length;
        const geoTotal = geometricNetwork.nodes.length;
        const geoIntegrity = geoTotal > 0 ? (geoAlive / geoTotal * 100).toFixed(1) : 0;
        
        const geoReconstructing = geometricNetwork.nodes.filter(n => n.reconstructing).length;
        const geoProgress = geoReconstructing > 0 ?
            geometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / geoReconstructing * 100 : 0;
        
        document.getElementById('geoIntegrity').textContent = geoIntegrity + '%';
        document.getElementById('geoProgress').textContent = geoProgress.toFixed(1) + '%';
        document.getElementById('geoActive').textContent = activeScales.size;
        
        // Non-geometric stats
        const nonGeoAlive = nongeometricNetwork.nodes.filter(n => n.alive).length;
        const nonGeoTotal = nongeometricNetwork.nodes.length;
        const nonGeoIntegrity = nonGeoTotal > 0 ? (nonGeoAlive / nonGeoTotal * 100).toFixed(1) : 0;
        
        const nonGeoReconstructing = nongeometricNetwork.nodes.filter(n => n.reconstructing).length;
        const nonGeoProgress = nonGeoReconstructing > 0 ?
            nongeometricNetwork.nodes.filter(n => n.reconstructing)
                .reduce((sum, n) => sum + n.reconstructProgress, 0) / nonGeoReconstructing * 100 : 0;
        
        document.getElementById('nonGeoIntegrity').textContent = nonGeoIntegrity + '%';
        document.getElementById('nonGeoProgress').textContent = nonGeoProgress.toFixed(1) + '%';
        document.getElementById('nonGeoErrors').textContent = nongeometricNetwork.errors;
    }
    
    function updateDamageLevel(value) {
        geometricNetwork.damageLevel = value / 100;
        nongeometricNetwork.damageLevel = value / 100;
        document.getElementById('damageValue').textContent = value + '%';
    }
    
    function resetSimulation() {
        if (animationFrame) {
            cancelAnimationFrame(animationFrame);
        }
        isReconstructing = false;
        activeScales.clear();
        
        originalCtx.fillStyle = '#000';
        originalCtx.fillRect(0, 0, 400, 300);
        geometricCtx.fillStyle = '#000';
        geometricCtx.fillRect(0, 0, 400, 300);
        nongeometricCtx.fillStyle = '#000';
        nongeometricCtx.fillRect(0, 0, 400, 300);
        
        geometricNetwork = { nodes: [], connections: [], geometricSeed: [], damageLevel: 0.3 };
        nongeometricNetwork = { nodes: [], connections: [], damageLevel: 0.3, errors: 0 };
        
        document.getElementById('fragmentBtn').disabled = true;
        document.getElementById('reconstructBtn').disabled = true;
        
        document.querySelectorAll('.scale-item').forEach(item => item.classList.remove('active'));
        
        logMessage('Simulation reset', 'info');
        updateStats();
    }
    
    function logMessage(message, type = 'info') {
        const logPanel = document.getElementById('logPanel');
        const entry = document.createElement('div');
        entry.className = `log-entry log-${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
    }
    
    async function runAutoDemo() {
        resetSimulation();
        await sleep(500);
        initializeSeed();
        await sleep(2000);
        startFragmentation();
        await sleep(2000);
        startBothReconstructions();
    }
    
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
</script>
```

</body>
</html>

